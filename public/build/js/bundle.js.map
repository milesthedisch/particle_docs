{"version":3,"sources":["webpack:///webpack/bootstrap 2057d4527c0c6ba76926","webpack:///./src/module/shims.js","webpack:///./src/module/dom_helper.js","webpack:///./src/app.js","webpack:///../particle_library/dist/main.js","webpack:///./src/module/iframeManager.js","webpack:///./src/styles/main.scss?8e39","webpack:///./src/styles/main.scss","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./public/files/fonts/Code Pro/Code Pro Regular.eot","webpack:///./public/files/fonts/Code Pro/Code Pro Regular.eot?1f36","webpack:///./public/files/fonts/Code Pro/Code Pro Regular.woff","webpack:///./public/files/fonts/Code Pro/Code Pro Regular.svg","webpack:///./public/files/fonts/Code Pro/Code Pro Regular.ttf","webpack:///./public/files/fonts/Code Pro/Code Pro Bold.eot","webpack:///./public/files/fonts/Code Pro/Code Pro Bold.eot?efa8","webpack:///./public/files/fonts/Code Pro/Code Pro Bold.woff","webpack:///./public/files/fonts/Code Pro/Code Pro Bold.svg","webpack:///./public/files/fonts/Code Pro/Code Pro Bold.ttf","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;AACV;AACA;;;;;;;ACdA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,UAAU;AACV;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;AC7DD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEljB,kDAAkD,0CAA0C,0DAA0D,EAAE;;AAExJ;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;;AAEA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,aAAa;AAC1C;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB,iBAAiB,EAAE;AACnB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,kBAAkB,WAAW,IAAI,WAAW,IAAI;AAChD;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,kBAAkB,WAAW,IAAI,WAAW,IAAI;AAChD,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA,qGAAqG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE3Q;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf,aAAa;AACb;AACA;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,aAAa,WAAW;AACxB,aAAa,WAAW;;AAExB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEljB,kDAAkD,0CAA0C,0DAA0D,EAAE;;AAExJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe;AACf;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,eAAe;AACf;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB;AACjB;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC,iBAAiB;AACjB;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA,sBAAsB,YAAY;AAClC;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,EAAE;AAChB;AACA;AACA;AACA,oBAAoB,SAAS,GAAG,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;;AAEA,6BAA6B,4BAA4B,aAAa,EAAE;;AAExE,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,IAAI;AACJ,EAAE;;AAEF;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO,WAAW;AAC9B,YAAY,SAAS;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,QAAQ;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA,8BAA8B,kBAAkB,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,EAAE;AACnE;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6BAA6B;;AAE7B,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA,+CAA+C;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;;AAEF;;AAEA,6BAA6B;;AAE7B,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA,+CAA+C;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,6BAA6B;;AAE7B,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO,WAAW;AAC9B,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO,WAAW;AAC9B,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,EAAE;AACd,YAAY,QAAQ;AACpB;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEljB,kDAAkD,0CAA0C,0DAA0D,EAAE;;AAExJ;;AAEA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+DAA+D,gEAAgE;AAC/H;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,WAAW;AACjC;AACA;AACA;;AAEA,sBAAsB,YAAY;AAClC;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,aAAa;AACtB,WAAW,iBAAiB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA,mCAAmC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAElM;AACA;AACA,WAAW;AACX,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,aAAa;AACb;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa;AACb;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa;AACb;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qEAAqE,eAAe;AACpF;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,2CAA2C,mDAAmD;;AAE9F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA,2CAA2C,cAAc,u9rR;;;;;;ACl5LzD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA,kD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjLA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gCAAgC,UAAU,EAAE;AAC5C,C;;;;;;ACzBA;AACA;;;AAGA;AACA,ubAAwb,4BAA4B,iCAAiC,0CAA0C,8CAA8C,aAAa,wKAAwK,cAAc,EAAE,uGAAuG,mBAAmB,EAAE,oJAAoJ,mBAAmB,qBAAqB,EAAE,6NAA6N,8BAA8B,EAAE,0DAA0D,qBAAqB,EAAE,yGAAyG,4BAA4B,yBAAyB,iCAAiC,aAAa,qJAAqJ,sCAAsC,8BAA8B,aAAa,uPAAuP,kCAAkC,qDAAqD,aAAa,kJAAkJ,qBAAqB,EAAE,0JAA0J,wBAAwB,0CAA0C,iDAAiD,aAAa,0GAA0G,yBAAyB,EAAE,uFAAuF,wBAAwB,EAA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D;;;;;;ACAA,mD;;;;;;ACAA,mD;;;;;;ACAA,oD;;;;;;ACAA,mD;;;;;;ACAA,mD;;;;;;ACAA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA,mBAAmB,2BAA2B;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA,QAAQ,uBAAuB;AAC/B;AACA;AACA,GAAG;AACH;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,kDAAkD,sBAAsB;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;;AAEA,6BAA6B,mBAAmB;;AAEhD;;AAEA;;AAEA;AACA;;;;;;;;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,EAAE;AACrD,wCAAwC,WAAW,EAAE;;AAErD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC,GAAG;AACH;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./public\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2057d4527c0c6ba76926","/* shims */\nmodule.exports = function shims(document) {\n  document = document || this.document;\n\n  const $ = function qs(...args) {\n    return document.querySelector(...args);\n  };\n\n  const $$ = function qsAll(...args) {\n    return document.querySelectorAll(...args);\n  };\n\n  return {$, $$};\n};\n/* shims */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/shims.js\n// module id = 0\n// module chunks = 0","module.exports = function (document) {\n  document = document || this.document;\n\n  const shims = require(\"shims\")(document);\n  const $$ = shims.$$;\n\n  /**\n   * isElement checks if a element is a DOM node.\n   * @param  {Object}  obj\n   * @return {Boolean}\n   */\n  const isElement = (obj) => obj instanceof HTMLElement;\n\n  /**\n   * mapText takes an elment list and return a array of textNodes.\n   * @param  {DOMElememt} elm   DOMElememt\n   * @return {Array}            Array\n   */\n  const mapToText = function mapText(elm) {\n    const elmList = $$(elm, document);\n    const textNodes = [];\n\n    /*\n      We need to use a for `of` loop here cause its a NodeList and not an\n      array.\n    */\n    for (let item of elmList) {\n      textNodes.push(item.text);\n    }\n\n    return textNodes;\n  };\n\n  /**\n   * elmDelegator delegate items\n   * @param  {DOMElement} elm The parent element of the delegates.\n   * @param  {String} event Boolean to check which elements to delegate to.\n   * @return {Function}\n   * Curried function that takes a checkTarget function and a callback.\n   */\n  const elmDelegator = function elmDelegator(elm, event) {\n    if (!isElement(elm)) throw new Error(elm + \" needs to be a element.\");\n    if (elm.length) throw new Error(elm + \" needs to be element list\");\n\n    return function(checkTarget, callback) {\n      elm.addEventListener(event, function(e) {\n        e.preventDefault();\n\n        if (checkTarget(e.target)) {\n          return callback(null, e.target, e);\n        }\n\n        return callback(null);\n      });\n    };\n  };\n\n  return {elmDelegator, mapToText, isElement};\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/dom_helper.js\n// module id = 1\n// module chunks = 0","window.particleLib = require(\"particle_library\");\nconst iframe = require(\"iframeManager.js\")(document);\nconst shims = require(\"shims.js\")(document);\nconst utils = require(\"dom_helper.js\")(document);\nconst sass = require(\"./styles/main.scss\");\nconst DEFAULT_EXAMPLE = \"random_vectors\";\n\nconst sethash = (fragment) => {\n  return window.location.hash = fragment || \"\";\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  const hash = window.location.hash;\n  const pathname = window.location.pathname;\n  const textNodes = utils.mapToText(\".list-examples li a\");\n  const $ = shims.$;\n\n  if (textNodes.length === 0) {\n    throw new Error(\"Theres no textNodes to check against.\");\n  }\n\n  switch (pathname) {\n  case(\"/\"): {\n    break;\n  }\n  case(\"/examples\"): {\n    const onClickOfList = utils.elmDelegator($(\".list-examples\"), \"click\");\n    const isAnchor = (elm) => elm.tagName === \"A\";\n\n    onClickOfList(isAnchor, function(err, target, evt) {\n      if (err) throw err;\n      if (!target && !evt) return;\n\n      sethash(target.text);\n      iframe.loadInIframe(target.text);\n    });\n\n    // If theres a page fragment load the right example.\n    if (hash.length) {\n      const hashQuery = hash.substr(1);\n\n      if (textNodes.indexOf(hashQuery) > -1) {\n        iframe.loadInIframe(hashQuery);\n      }\n    }\n\n   // Default to the an example if theres no hash.\n    if (hash.length < 1) {\n      sethash(DEFAULT_EXAMPLE);\n      iframe.loadInIframe(DEFAULT_EXAMPLE);\n    }\n    break;\n  }\n\n  case(\"/maths\"): {\n    break;\n  }\n  default: {\n    console.log(\"no route matched 404 :(\");\n  }\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app.js\n// module id = 2\n// module chunks = 0","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"particle\"] = factory();\n\telse\n\t\troot[\"particle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar Vector = __webpack_require__(2);\n\tvar Particle = __webpack_require__(4);\n\tvar Utils = __webpack_require__(3);\n\tvar Shapes = __webpack_require__(118);\n\tvar YAT = __webpack_require__(119);\n\tvar Clock = __webpack_require__(121);\n\tvar Ticker = __webpack_require__(122);\n\t\n\tmodule.exports = {\n\t  Vector: Vector,\n\t  Particle: Particle,\n\t  Utils: Utils,\n\t  Shapes: Shapes,\n\t  YAT: YAT,\n\t  Ticker: Ticker,\n\t  Clock: Clock\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* eslint max-len: 0 */\n\t\n\t//      \n\t\n\tvar utils = __webpack_require__(3);\n\t\n\tvar INITIAL_STATE = {\n\t  x: 0,\n\t  y: 1\n\t};\n\t\n\t/**\n\t * Vector class is responsible for doing vector operations and storing\n\t * the x and y coordinates of the vector.\n\t */\n\t\n\t/**\n\t * @class Vector\n\t * @param {Object} state object.\n\t */\n\t\n\tvar Vector = function () {\n\t\n\t  /**\n\t   * constructor\n\t   * @param  {Object} state Initial state\n\t   */\n\t  function Vector() {\n\t    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;\n\t\n\t    _classCallCheck(this, Vector);\n\t\n\t    this.state = state;\n\t  }\n\t\n\t  /**\n\t   * Create - Easy way to instantiate a vector.\n\t   * @memberOf Vector\n\t   * @param  {Int} x\n\t   * @param  {Int} y\n\t   * @return {Vector}   A object inheriting from Vector.\n\t   */\n\t\n\t\n\t  _createClass(Vector, [{\n\t    key: \"create\",\n\t    value: function create() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t      var vec = new Vector({ x: x, y: y });\n\t      return vec;\n\t    }\n\t  }, {\n\t    key: \"set\",\n\t\n\t\n\t    /**\n\t     * Set - A setter for the vector class.\n\t     * @memberOf Vector\n\t     * @param  {*} prop\n\t     * @param  {*} val\n\t     * @return {Boolean} Is the prop your passing in exsist.\n\t     */\n\t    value: function set(prop, val) {\n\t      // TODO: Add check val is number\n\t      // 1. Create utils.isNumber function.\n\t\n\t      if (this.state.hasOwnProperty(prop)) {\n\t        this.state[prop] = val;\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t  }, {\n\t    key: \"get\",\n\t\n\t\n\t    /**\n\t     * get - A getter for the vector class.\n\t     * @memberOf Vector\n\t     * @param  {String} prop  The prop to set on state.\n\t     * @return {Value}        The value assosiated with the prop.\n\t     */\n\t    value: function get(prop) {\n\t      return this.state[prop];\n\t    }\n\t  }, {\n\t    key: \"setAngle\",\n\t\n\t\n\t    /**\n\t     * setAngle - Plot the corrdinates based on radians given.\n\t     * @memberOf Vector\n\t     * @param {Radians} rad A floating point number.\n\t     * @return {Vector}\n\t     */\n\t    value: function setAngle(rad) {\n\t      // TODO: Add check rad is number\n\t      // 1. Create utils.isNumber function.\n\t\n\t      var length = this.getLength();\n\t\n\t      this.set(\"x\", Math.cos(rad) * length);\n\t      this.set(\"y\", Math.sin(rad) * length);\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"setLength\",\n\t\n\t\n\t    /**\n\t     * setLength - Takes a length and sets coordinate.\n\t     * @memberOf Vector\n\t     * @param {Integer} length\n\t     * @return {Vector}\n\t     */\n\t    value: function setLength(length) {\n\t      // TODO: Add check rad is number\n\t      // 1. Create utils.isNumber function.\n\t\n\t      var rad = this.getAngle();\n\t\n\t      this.set(\"x\", Math.cos(rad) * length);\n\t      this.set(\"y\", Math.sin(rad) * length);\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"getLength\",\n\t\n\t\n\t    /**\n\t     * getLength - Gets length of the coordinates from center plane.\n\t     * @memberOf Vector\n\t     * @return {Integer} Cooridinates.\n\t     */\n\t    value: function getLength() {\n\t      var x = this.get(\"x\");\n\t      var y = this.get(\"y\");\n\t      return Math.hypot(x, y);\n\t    }\n\t  }, {\n\t    key: \"getAngle\",\n\t\n\t\n\t    /**\n\t     * getAngle - Get the angle of coordinates from center plane.\n\t     * @memberOf Vector\n\t     * @return {Integer} Cooridinates.\n\t     */\n\t    value: function getAngle() {\n\t      var x = this.get(\"x\");\n\t      var y = this.get(\"y\");\n\t      return Math.atan2(y, x);\n\t    }\n\t  }, {\n\t    key: \"random\",\n\t\n\t\n\t    /**\n\t     * random generate a vector with random states.\n\t     * @memberOf Vector\n\t     * @param {Number} min - A min range on the random vector state.\n\t     * @param {Number} max - A max range on the random vector state.\n\t     * @return {Vector}\n\t     */\n\t    value: function random() {\n\t      var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\t      var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\t\n\t      var x = utils.lerp(Math.random(), min, max);\n\t      var y = utils.lerp(Math.random(), min, max);\n\t      return this.create(x, y);\n\t    }\n\t  }, {\n\t    key: \"randomBetween\",\n\t\n\t\n\t    /**\n\t     * @memberOf Vector\n\t     * @description Return a vector that has a x between the given range.\n\t     *              and y given a range.\n\t     * @param  {Number} xMin Minmum x value\n\t     * @param  {Number} xMax Maximum x value\n\t     * @param  {Number} yMin Minmum y value\n\t     * @param  {Number} yMax Maximum y value\n\t     * @return {Vector}\n\t     */\n\t    value: function randomBetween() {\n\t      var xMin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      var xMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\t      var yMin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t      var yMax = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n\t\n\t      xMax = Math.max(xMin, xMax);\n\t      xMin = Math.min(xMin, xMax);\n\t      yMax = Math.max(yMin, yMax);\n\t      yMin = Math.min(yMin, yMax);\n\t\n\t      var y = utils.randomBetween(yMin, yMax);\n\t      var x = utils.randomBetween(xMin, xMax);\n\t\n\t      return this.create(x, y);\n\t    }\n\t  }, {\n\t    key: \"add\",\n\t\n\t\n\t    /**\n\t     * add - Should add vectors together given a vector\n\t     * @memberOf Vector\n\t     * @param {Vector} v2 A given vector to add.\n\t     * @return {Vector} A vector with cooridnates, or multiple vectors.\n\t     */\n\t    value: function add(v2) {\n\t      return this.create(this.get(\"x\") + v2.get(\"x\"), this.get(\"y\") + v2.get(\"y\"));\n\t    }\n\t  }, {\n\t    key: \"subtract\",\n\t\n\t\n\t    /**\n\t     * subtract - should subtract the given vector with its own vector.\n\t     * @memberOf Vector\n\t     * @param  {Vector} v2 A vector that contains state.\n\t     * @return {Vector} A vector that contains a reduced state.\n\t     * @example {x: 2, y: 2} - {x: 2, y: 2} = {x: 0, y: 0}\n\t     */\n\t    value: function subtract(v2) {\n\t      return this.create(this.get(\"x\") - v2.get(\"x\"), this.get(\"y\") - v2.get(\"y\"));\n\t    }\n\t  }, {\n\t    key: \"multiply\",\n\t\n\t\n\t    /**\n\t     * Mulitplying vectors together\n\t     * @memberOf Vector\n\t     * @example {x: 2, y: 2} * {x: 2, y: 2} = {x: 4, y: 4}\n\t     * @param  {Vector} v2 A vector that contains state.\n\t     * @return {Vector}    A vector that contains a reduced state.\n\t     */\n\t    value: function multiply(v2) {\n\t      return this.create(this.get(\"x\") * v2.get(\"x\"), this.get(\"y\") * v2.get(\"y\"));\n\t    }\n\t  }, {\n\t    key: \"divide\",\n\t\n\t\n\t    /**\n\t     * Divide vectors together.\n\t     * @memberOf Vector\n\t     * @param  {Vector} v2 A vector that contains state.\n\t     * @return {Vector}    A vector that contains a reduced state.\n\t     */\n\t    value: function divide(v2) {\n\t      return this.create(this.get(\"x\") / v2.get(\"x\"), this.get(\"y\") / v2.get(\"y\"));\n\t    }\n\t  }, {\n\t    key: \"addTo\",\n\t\n\t\n\t    /**\n\t     * Adds to current state the state of v2\n\t     * @memberOf Vector\n\t     * @param {Vector} [v2] - A vector that contains state.\n\t     * @return {Object} [state] - Key value pair of coordinates\n\t     */\n\t    value: function addTo(v2) {\n\t      this.state.x = this.get(\"x\") + v2.get(\"x\");\n\t      this.state.y = this.get(\"y\") + v2.get(\"y\");\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"subtractFrom\",\n\t\n\t\n\t    /**\n\t     * Subtracts from current state the state of v2\n\t     * @memberOf Vector\n\t     * @param {Vector} [v2] - A vector that contains state.\n\t     * @return {Object} [state] - Key value pair of coordinates\n\t     */\n\t    value: function subtractFrom(v2) {\n\t      this.state.x = this.get(\"x\") - v2.get(\"x\");\n\t      this.state.y = this.get(\"y\") - v2.get(\"y\");\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"multiplyBy\",\n\t\n\t\n\t    /**\n\t     * mulitplies by current state the state of v2\n\t     * @memberOf Vector\n\t     * @param {Vector} [v2] - A vector that contains state.\n\t     * @return {Object} [state] - Key value pair of coordinates\n\t     */\n\t    value: function multiplyBy(v2) {\n\t      this.state.x = this.get(\"x\") * v2.get(\"x\");\n\t      this.state.y = this.get(\"y\") * v2.get(\"y\");\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"divideBy\",\n\t\n\t\n\t    /**\n\t     * Divides by current state the state of v2\n\t     * @memberOf Vector\n\t     * @param {Vector} [v2] - A vector that contains state.\n\t     * @return {Object} [state] - Key value pair of coordinates\n\t     */\n\t    value: function divideBy(v2) {\n\t      this.state.x = this.get(\"x\") / v2.get(\"x\");\n\t      this.state.y = this.get(\"y\") / v2.get(\"y\");\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"rotateBy\",\n\t\n\t\n\t    /**\n\t     * @memberOf Vector\n\t     * @param  {Number} angle A number of radians to rotate clockwise by.\n\t     * @return {Vector}\n\t    */\n\t    value: function rotateBy(angle) {\n\t      var cos = Math.cos(angle);\n\t      var sin = Math.sin(angle);\n\t\n\t      var x = this.state.x * cos - this.state.y * sin;\n\t      var y = this.state.y * cos + this.state.x * sin;\n\t\n\t      this.state.x = x;\n\t      this.state.y = y;\n\t\n\t      return this;\n\t    }\n\t  }], [{\n\t    key: \"distanceBetween\",\n\t\n\t\n\t    /**\n\t     * v1\n\t     * @param {Vector} v1 Vector\n\t     * @param {Vector} v2 Vector\n\t     * @return {number}\n\t     */\n\t    value: function distanceBetween(v1, v2) {\n\t      var dVec = v1.subtract(v2);\n\t      return Math.hypot(dVec.get(\"x\"), dVec.get(\"y\"));\n\t    }\n\t\n\t    /**\n\t     * @description Given twos vectors see if they intersect.\n\t     * @memberOf Utils\n\t     * @param  {Vector} vec0\n\t     * @param  {Vector} vec1\n\t     * @return {Boolean}\n\t     */\n\t\n\t  }, {\n\t    key: \"vectorIntersect\",\n\t    value: function vectorIntersect(vec0, vec1) {\n\t      var x0 = vec0.get(\"x\");\n\t      var y0 = vec0.get(\"y\");\n\t      var x1 = vec1.get(\"x\");\n\t      var y1 = vec1.get(\"y\");\n\t      return utils.rangeIntersect(x0, y0, x1, y1);\n\t    }\n\t  }]);\n\t\n\t  return Vector;\n\t}();\n\t\n\t;\n\t\n\tmodule.exports = Vector;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t//      \n\t\n\t/* eslint max-len: 0 */\n\t\n\t/**\n\t * This module is composed of small function that\n\t * should be used when needed. Most functions are pure\n\t * and only return values. For more info read the docs.\n\t */\n\t\n\t/**\n\t * normalize - Takes a max and min value and returns\n\t * a floating point number, that when multiplied\n\t * by one hundred represents a precentage of the range\n\t * between max and min.\n\t *\n\t * @memberOf Utils\n\t * @param  {Int} val - The value that lies in the range.\n\t * @param  {Int} min - The maxium value in the range.\n\t * @param  {Int} max - The minimum value in the range.\n\t * @return {Int} Int - The value represented in that range.\n\t */\n\tfunction normalize(val, min, max) {\n\t  return (val - min) / (max - min);\n\t};\n\t\n\t/**\n\t * lerp - linear interpolation takes a range and a given normalized value\n\t * and returns a value that represents that normalized value in that range.\n\t * @memberOf Utils\n\t * @param  {Interger} val\n\t * @param  {Interger} min\n\t * @param  {Interger} max\n\t * @return {Interger}\n\t */\n\tfunction lerp(val, min, max) {\n\t  return (max - min) * val + min;\n\t};\n\t\n\t/**\n\t * map - Given 2 set of values map them to another set.\n\t * @memberOf Utils\n\t * @param  {number} value\n\t * @param  {number} srcMin\n\t * @param  {number} srcMax\n\t * @param  {number} destMin\n\t * @param  {number} destMax\n\t * @return {number}\n\t */\n\tfunction map(value, srcMin, srcMax, destMin, destMax) {\n\t  srcMax = Math.max(srcMax, srcMin);\n\t  srcMin = Math.min(srcMax, srcMin);\n\t  destMin = Math.min(destMin, destMax);\n\t  destMax = Math.max(destMin, destMax);\n\t  return lerp(normalize(value, srcMin, srcMax), destMin, destMax);\n\t};\n\t\n\t/**\n\t * @description Takes a value and returns a precentage.\n\t *              you can pass arbitrary large numbers in but thats not\n\t *              the intended purpose of this function.\n\t * @param  {Float} val \tA value.\n\t * @memberOf Utils\n\t * @return {Percent}    A value.\n\t */\n\tfunction percent(val) {\n\t  return val * 100;\n\t};\n\t\n\t/**\n\t * @description Given a number and a range return the\n\t *              value between that range or the max number or min number.\n\t * @memberOf Utils\n\t * @param  {Number} value\n\t * @param  {Number} min\n\t * @param  {Number} max\n\t * @return {Number}\n\t */\n\tfunction clamp(value, min, max) {\n\t  return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max));\n\t};\n\t\n\t/**\n\t * @memberOf  Utils\n\t * @description Given two numbers return a random number between the two.\n\t * @param  {Integer} x\n\t * @param  {Integer} y\n\t * @return {Integer}\n\t */\n\tfunction randomBetween(x, y) {\n\t  var min = Math.min(x, y);\n\t  var max = Math.max(x, y);\n\t  return Math.floor(Math.random() * (max - min)) + min;\n\t};\n\t\n\t/**\n\t * @description Given two coordinates return the distance between the two.\n\t * @memberOf Utils\n\t * @param  {Number} x0\n\t * @param  {Number} y0\n\t * @param  {Number} x1\n\t * @param  {Number} y1\n\t * @return {Number}\n\t */\n\tfunction distanceXY(x0, y0, x1, y1) {\n\t  var dx = x0 - x1;\n\t  var dy = y0 - y1;\n\t  return Math.hypot(dx, dy);\n\t};\n\t\n\t/**\n\t * @description given a number\n\t * @memberOf Utils\n\t * @param  {Number} val\n\t * @param  {Number} min\n\t * @param  {Number} max\n\t * @return {Boolean}\n\t */\n\tfunction inRange(val, min, max) {\n\t  return val <= Math.max(max, min) && Math.min(max, min) <= val;\n\t};\n\t\n\t/**\n\t * @description Given a two ranges see if both intersect each other.\n\t * @memberOf Utils\n\t * @param  {Number} min0\n\t * @param  {Number} max0\n\t * @param  {Number} min1\n\t * @param  {Number} max1\n\t * @return {Boolean}\n\t */\n\tfunction rangeIntersect(min0, max0, min1, max1) {\n\t  return Math.max(max0, min0) >= Math.min(min1, max1) && Math.min(min0, max0) <= Math.max(max1, min1);\n\t};\n\t\n\t/**\n\t * @description Given two rectange see if the intersect.\n\t * @memberOf Utils\n\t * @param  {Particle} r0\n\t * @param  {Particle} r1\n\t * @return {Boolean}\n\t */\n\tfunction collisionRect(r0, r1) {\n\t  var r0x = r0.state.x;\n\t  var r0y = r0.state.y;\n\t  var r1x = r1.state.x;\n\t  var r1y = r1.state.y;\n\t\n\t  var r0w = r0x + r0.state.width;\n\t  var r0h = r0y + r0.state.height;\n\t  var r1w = r1x + r1.state.width;\n\t  var r1h = r1y + r1.state.height;\n\t\n\t  return rangeIntersect(r0x, r0w, r1x, r1w) && rangeIntersect(r0y, r0h, r1y, r1h);\n\t};\n\t\n\t/**\n\t * @description Given to particle with radi return wether they collide are not\n\t * @memberOf Utils\n\t * @param  {Particle} c1\n\t * @param  {Particle} c2\n\t * @return {Boolean}\n\t */\n\tfunction collisionCircle(c1, c2) {\n\t  var radi = c1.state.radius + c2.state.radius;\n\t  var distance = distanceXY(c1.state.x, c1.state.y, c2.state.x, c2.state.y);\n\t\n\t  if (distance) {\n\t    return radi > distance;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * @description Given a point and a circle return a boolean regarding wether they are colliding.\n\t * @memberOf Utils\n\t * @param  {Number}   x\n\t * @param  {Number}   y\n\t * @param  {Particle} circle\n\t * @return {Boolean}\n\t */\n\tfunction collisionCirclePoint(x, y, circle) {\n\t  // TODO Write tests.\n\t  var dist = distanceXY(x, y, circle.state.x, circle.state.y);\n\t\n\t  return circle.state.radius > dist;\n\t};\n\t\n\t/**\n\t * @description detect a collision between circles a vector.\n\t * @memberOf Utils\n\t * @param  {Vector}   vec\n\t * @param  {Particle} circle\n\t * @return {Boolean}\n\t */\n\tfunction collisionCircleVec(vec, circle) {\n\t  return circle.state.radius > distanceXY(vec.get(\"x\"), vec.get(\"y\"), circle.state.x, circle.state.y);\n\t};\n\t\n\t/**\n\t * @description detect collision of a rectangle and a point.\n\t * @memberOf Utils\n\t * @param  {Number}   x\n\t * @param  {Number}   y\n\t * @param  {Particle} rect\n\t * @return {Boolean}\n\t */\n\tfunction collisionRectPoint(x, y, rect) {\n\t  var rectX = rect.state.x;\n\t  var rectY = rect.state.y;\n\t  return inRange(x, rectX, rectX + rect.state.width) && inRange(y, rectY, rectY + rect.state.height);\n\t};\n\t\n\t/**\n\t * @description Given a vector and a retangle check wether they collided.\n\t * @memberOf Utils\n\t * @param  {Vector}   vec\n\t * @param  {Particle} rect\n\t * @return {Boolean}\n\t */\n\tfunction collisionRectVec(vec, rect) {\n\t  return collisionRectPoint(vec.get(\"x\"), vec.get(\"y\"), rect);\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description Run a function only if the given time to allow the function execute\n\t * has passed. If\n\t * @param  {Function} func A function to call every delta.\n\t * @param  {Number} wait The minimum time to wait.\n\t * @param  {Object} options\n\t * @return {Function}\n\t * @see underscore\n\t */\n\tfunction throttle(func, wait, options) {\n\t  var context = void 0;\n\t  var args = void 0;\n\t  var result = void 0;\n\t  var timeout = null;\n\t  var previous = 0;\n\t  if (!options) options = {};\n\t  var later = function later() {\n\t    previous = options.leading === false ? 0 : Date.now();\n\t    timeout = null;\n\t    result = func.apply(context, args);\n\t    if (!timeout) context = args = null;\n\t  };\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var now = Date.now();\n\t    if (!previous && options.leading === false) previous = now;\n\t    var remaining = wait - (now - previous);\n\t    context = this;\n\t    args = args;\n\t    if (remaining <= 0 || remaining > wait) {\n\t      if (timeout) {\n\t        clearTimeout(timeout);\n\t        timeout = null;\n\t      }\n\t      previous = now;\n\t      result = func.apply(context, args);\n\t      if (!timeout) context = args = null;\n\t    } else if (!timeout && options.trailing !== false) {\n\t      timeout = setTimeout(later, remaining);\n\t    }\n\t    return result;\n\t  };\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description - Setting the length of a vector.\n\t * @param   {number} length\n\t * @param   {number} x\n\t * @param   {number} y\n\t * @return  {number[]} Coordinates\n\t */\n\tfunction setLength(length, x, y) {\n\t  if (typeof x !== \"number\" || typeof y !== \"number\" || typeof length !== \"number\") {\n\t    throw new Error(\"Please provide valid x and y values\");\n\t  }\n\t\n\t  var angle = Math.atan2(y, x);\n\t  x = Math.cos(angle) * length;\n\t  y = Math.sin(angle) * length;\n\t\n\t  return [x, y];\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description - Setting the angle of a vector.\n\t * @param   {number} angle\n\t * @param   {number} x\n\t * @param   {number} y\n\t * @return  {number[]} coordinates\n\t */\n\tfunction setAngle(angle, x, y) {\n\t  if (typeof x !== \"number\" || typeof y !== \"number\" || typeof angle !== \"number\") {\n\t    throw new Error(\"Please provide valid x and y values\");\n\t  }\n\t\n\t  var length = Math.hypot(x, y);\n\t  x = Math.cos(angle) * length;\n\t  y = Math.sin(angle) * length;\n\t\n\t  return [x, y];\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description Coverts degrees to radians\n\t * @param  {number} deg Degress\n\t * @return {number}\n\t */\n\tfunction degToRad(deg) {\n\t  return deg / 180 * Math.PI;\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description Coverts radians to degress\n\t * @param  {number} rad\n\t * @return {number}\n\t */\n\tfunction radToDeg(rad) {\n\t  return rad * 180 / Math.PI;\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description Round to nearest place given.\n\t * @param  {number} val\n\t * @param  {number} places An exponent\n\t * @return {number}\n\t */\n\tfunction roundToPlaces(val, places) {\n\t  var mult = Math.pow(10, places);\n\t  return Math.round(val * mult) / mult;\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @param  {number} val\n\t * @param  {number} nearest\n\t * @return {number}\n\t */\n\tfunction roundToMultiple(val, nearest) {\n\t  if (!nearest) {\n\t    throw new Error(\"Nothing can be a multiple of \" + String(nearest));\n\t  }\n\t  return Math.round(val / nearest) * nearest;\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @param  {number} v0\n\t * @param  {number} v1\n\t * @param  {number} v2\n\t * @param  {number} t\n\t * @param  {number} pFinal\n\t * @return {number}\n\t */\n\tfunction quadraticBezier(v0, v1, v2, t) {\n\t  return Math.pow(1 - t, 2) * v0 + (1 - t) * 2 * t * v1 + t * t * v2;\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @param  {number} v0\n\t * @param  {number} v1\n\t * @param  {number} v2\n\t * @param  {number} v3\n\t * @param  {number} t\n\t * @param  {number} pFinal\n\t * @return {number}\n\t */\n\tfunction cubicBezier(v0, v1, v2, v3, t) {\n\t  return Math.pow(1 - t, 3) * v0 + Math.pow(1 - t, 2) * 3 * t * v1 + (1 - t) * 3 * t * t * v2 + t * t * t + v3;\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} t\n\t * @param  {Object} pFinal\n\t * @return {number}\n\t */\n\tfunction quadraticBezierPoint(p0, p1, p2, t) {\n\t  var x = quadraticBezier(p0.x, p1.x, p2.x, t);\n\t  var y = quadraticBezier(p0.y, p1.y, p2.y, t);\n\t  return { x: x, y: y };\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @param  {number} p0\n\t * @param  {number} p1\n\t * @param  {number} p2\n\t * @param  {number} p3\n\t * @param  {number} t\n\t * @param  {Object} pFinal\n\t * @return {number}\n\t */\n\tfunction cubicBezierPoint(p0, p1, p2, p3, t) {\n\t  var x = cubicBezier(p0.x, p1.x, p2.x, p3.x, t);\n\t  var y = cubicBezier(p0.y, p1.y, p2.y, p3.y, t);\n\t  return { x: x, y: y };\n\t};\n\t\n\t/**\n\t * @memberOf Utils\n\t * @description Given points on the plane draw a curved line between\n\t * all of them.\n\t * @param  {{number, number}} points\n\t * @param  {CanvasRenderingContext2D} ctx\n\t */\n\tfunction multiCurve(points, ctx) {\n\t  var p0 = void 0;\n\t  var p1 = void 0;\n\t  var midX = void 0;\n\t  var midY = void 0;\n\t\n\t  ctx.moveTo(points[0].x, points[0].y);\n\t\n\t  for (var i = 1; i < points.length - 2; i++) {\n\t    p0 = points[i];\n\t    p1 = points[i + 1];\n\t    midX = (p0.x + p1.x) / 2;\n\t    midY = (p0.y + p1.y) / 2;\n\t    ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);\n\t  }\n\t\n\t  p0 = points[points.length - 2];\n\t  p1 = points[points.length - 1];\n\t  ctx.quadraticCurveTo(p0.x, p0.y, p1.x, p1.y);\n\t};\n\t\n\t/**\n\t * ease\n\t * @memberOf Utils\n\t * @param  {Float} ease\n\t * @param  {Int} a\n\t * @param  {Int} b\n\t * @param  {number} threshold\n\t * @return {Int}\n\t */\n\tfunction ease(ease, a, b) {\n\t  var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;\n\t\n\t  // the delta can get extremely small and its not performant to keep\n\t  // on rendering or calculating for animation purposes.\n\t  if (Math.abs(b - a) < threshold) {\n\t    return false;\n\t  }\n\t\n\t  return (b - a) * ease;\n\t};\n\t\n\t/**\n\t * easeTo\n\t * @param  {number} ease:      number        Ease factor.\n\t * @param  {Object} origin:    Object        The starting point.\n\t * @param  {Object} target:    Object        The ending point.\n\t * @param  {Number} threshold: number        Easing threshold.\n\t * @return {Object}\n\t */\n\tfunction easeTo(ease, origin, target) {\n\t  var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;\n\t\n\t  var dx = target.x - origin.x;\n\t  var dy = target.y - origin.y;\n\t\n\t  // the delta can get extremely small and its not performant to keep\n\t  // on rendering or calculating for animation purposes.\n\t  if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {\n\t    return false;\n\t  }\n\t\n\t  origin.x += dx * ease;\n\t  origin.y += dy * ease;\n\t\n\t  return origin;\n\t};\n\t\n\t/**\n\t * isPlainObject\n\t * @param  {*}  data\n\t * @return {Boolean}\n\t */\n\tfunction isObject(data) {\n\t  return (typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) === \"object\" && {}.toString.call(data) === \"[object Object]\";\n\t};\n\t\n\t/**\n\t * unique return an array with no duplicate values\n\t * @param  {Array} array\n\t * @return {Array}\n\t */\n\tfunction unique(array) {\n\t  return array.reduce(function (x, y) {\n\t    if (x.indexOf(y) === -1) x.push(y);\n\t    return x;\n\t  }, []);\n\t};\n\t\n\t// function colorInterpolation(float: number, colorFrom: Color, colorTo: Color) : Color {\n\t//   const {r1, g1, b1} = colorFrom;\n\t//   const {r2, g2, b2} = colorTo;\n\t\n\t//   const r = r1 + (r2 - r1) / float;\n\t//   const g = g1 + (g2 - g1) / float;\n\t//   const b = b1 + (b2 - b1) / float;\n\t\n\t//   return \"someHex\";\n\t// };\n\t\n\t/**\n\t * perspective - perspective is the ratio to multiply the x and y values\n\t * by to get those points represeneted in 3d space.\n\t * @param  {number} focalLength: The length of the lens\n\t * @param  {number} distance:    The distance from begining of the lens the the beginging of the object.\n\t * @return {number}``\n\t */\n\tfunction perspective(focalLength, distance) {\n\t  return focalLength / (focalLength - distance);\n\t};\n\t\n\t/**\n\t * @class Utils\n\t * @return {Utils}\n\t */\n\t\n\tmodule.exports = {\n\t  normalize: normalize,\n\t  lerp: lerp,\n\t  map: map,\n\t  percent: percent,\n\t  clamp: clamp,\n\t  randomBetween: randomBetween,\n\t  distanceXY: distanceXY,\n\t  inRange: inRange,\n\t  rangeIntersect: rangeIntersect,\n\t  collisionRect: collisionRect,\n\t  collisionCircle: collisionCircle,\n\t  collisionCirclePoint: collisionCirclePoint,\n\t  collisionCircleVec: collisionCircleVec,\n\t  collisionRectPoint: collisionRectPoint,\n\t  collisionRectVec: collisionRectVec,\n\t  throttle: throttle,\n\t  setLength: setLength,\n\t  setAngle: setAngle,\n\t  degToRad: degToRad,\n\t  radToDeg: radToDeg,\n\t  roundToPlaces: roundToPlaces,\n\t  roundToMultiple: roundToMultiple,\n\t  quadraticBezier: quadraticBezier,\n\t  cubicBezier: cubicBezier,\n\t  quadraticBezierPoint: quadraticBezierPoint,\n\t  cubicBezierPoint: cubicBezierPoint,\n\t  multiCurve: multiCurve,\n\t  perspective: perspective,\n\t  ease: ease,\n\t  easeTo: easeTo,\n\t  isObject: isObject,\n\t  unique: unique\n\t};\n\t\n\t// module.exports = Object.create(Utils);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//      \n\t\n\t/* eslint max-len: 0 */\n\t\n\t/*\n\t* The particle libary is used for physics animations.\n\t* they are not extremely accurate but still represent\n\t* and feel somewhat like physical movments.\n\t*/\n\t\n\tvar extend = __webpack_require__(5);\n\tvar clone = __webpack_require__(6);\n\t\n\t/* The default state a particle starts with It should not move. */\n\t\n\tvar INITIAL_STATE = {\n\t  x: 0,\n\t  y: 0,\n\t  vx: 0,\n\t  vy: 0,\n\t  gravity: 0,\n\t  magnitude: 0,\n\t  radius: 1,\n\t  mass: 1,\n\t  direction: Math.PI * 2,\n\t  friction: 1,\n\t  springs: [],\n\t  masses: [],\n\t  color: \"#000000\",\n\t  width: 10,\n\t  height: 10\n\t};\n\t\n\t/**\n\t * @class Particle\n\t * @param {state} state initial state to pass the constructor\n\t */\n\t\n\tvar Particle = function () {\n\t\n\t  /**\n\t   * constructor\n\t   * @constructor\n\t   * @param  {state} state Particle state coordinates, etc.\n\t   * @return {void}\n\t   */\n\t  function Particle() {\n\t    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : clone(INITIAL_STATE);\n\t\n\t    _classCallCheck(this, Particle);\n\t\n\t    this.state = state || {};\n\t  }\n\t\n\t  _createClass(Particle, [{\n\t    key: \"accelerate\",\n\t\n\t\n\t    /**\n\t     * @description A change in velocity.\n\t     *\n\t     * @memberOf Particle\n\t     * @param  {Integer} ax\n\t     * @param  {Integer} ay\n\t     * @return {void} Acceleration vector.\n\t     */\n\t    value: function accelerate() {\n\t      var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.vx;\n\t      var ay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.vy;\n\t\n\t      this.state.vx += ax;\n\t      this.state.vy += ay;\n\t    }\n\t  }, {\n\t    key: \"update\",\n\t\n\t\n\t    /**\n\t     * @description A update a position of a particle\n\t     * based on its gravity and fricition. Gravity is usually a acceleration\n\t     * vector.\n\t     *\n\t     * @memberOf Particle\n\t     * @param  {Integer} fric Fricition to apply.\n\t     * @param  {Integer} grav Gravity to apply.\n\t     * @return {Object} Position state.\n\t     */\n\t    value: function update() {\n\t      var fric = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.friction;\n\t      var grav = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.gravity;\n\t\n\t      // Apply springs\n\t      this.handleSprings();\n\t\n\t      // Apply gravitations\n\t      this.handleMasses();\n\t\n\t      // Apply fake fricition to velocity\n\t      this.state.vx *= fric;\n\t      this.state.vy *= fric;\n\t\n\t      // Apply gravity to velocity\n\t      this.accelerate(0, grav);\n\t\n\t      // Update position based on acceleration\n\t      return this.updatePos();\n\t    }\n\t  }, {\n\t    key: \"setSpeed\",\n\t\n\t\n\t    /**\n\t     * @description sets the internal speed of the particle given the force\n\t     * @memberOf Particle\n\t     * @param {number} speed\n\t     */\n\t    value: function setSpeed(speed) {\n\t      var angle = this.getHeading();\n\t      this.state.vx = Math.cos(angle) * speed;\n\t      this.state.vy = Math.sin(angle) * speed;\n\t    }\n\t  }, {\n\t    key: \"setHeading\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description sets the internal speed of the particle given the angle\n\t     * @param {number} angle\n\t     */\n\t    value: function setHeading(angle) {\n\t      var speed = this.getSpeed();\n\t      this.state.vx = Math.cos(angle) * speed;\n\t      this.state.vy = Math.sin(angle) * speed;\n\t    }\n\t  }, {\n\t    key: \"getSpeed\",\n\t\n\t\n\t    /**\n\t     * @description get the length of the velocity vector.\n\t     * @memberOf Particle\n\t     * @param  {number} x\n\t     * @param  {number} y\n\t     * @return {number} force of velocity vector.\n\t     */\n\t    value: function getSpeed() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.vx;\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.vy;\n\t\n\t      return Math.hypot(this.state.vx, this.state.vy);\n\t    }\n\t  }, {\n\t    key: \"getHeading\",\n\t\n\t\n\t    /**\n\t     * @description get the angle of the velocity vector.\n\t     * @memberOf Particle\n\t     * @param  {number} x\n\t     * @param  {number} y\n\t     * @return {number} angle of velocity vector.\n\t     */\n\t    value: function getHeading() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.vx;\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.vy;\n\t\n\t      return Math.atan2(y, x);\n\t    }\n\t  }, {\n\t    key: \"angleTo\",\n\t\n\t\n\t    /**\n\t     * @description Asumming we know where\n\t     * the other particle is on the canvas. We can use\n\t     * the angle formulae to figure out the angle\n\t     * between two particle. Using arctangent is fine.\n\t     * but because the corrdinate plane is filped on the\n\t     * Y axis we use atan2 to get the right values. Explained\n\t     * in API Docs.\n\t     *\n\t     * @memberOf Particle\n\t     * @param  {Particle} p      A particle instance.\n\t     * @return {Integer}  Angle   A angle.\n\t     */\n\t    value: function angleTo(p) {\n\t      var dx = p.state.x - this.state.x;\n\t      var dy = p.state.y - this.state.y;\n\t      return Math.atan2(dy, dx);\n\t    }\n\t  }, {\n\t    key: \"distanceTo\",\n\t\n\t\n\t    /**\n\t     * @description Assuming we know where both particle are on the canvas.\n\t     * we can use the distance formuale to figure out the distance\n\t     * between the two particles.\n\t     *\n\t     * @memberOf Particle\n\t     * @param  {Particle} p      A particle instance\n\t     * @return {number}  Angle   A Distance\n\t     */\n\t    value: function distanceTo(p) {\n\t      var dx = p.state.x - this.state.x;\n\t      var dy = p.state.y - this.state.y;\n\t      return Math.hypot(dx, dy);\n\t    }\n\t  }, {\n\t    key: \"addMass\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Append a particle to the masses array.\n\t     * @param {Particle} mass\n\t     */\n\t    value: function addMass(mass) {\n\t      this.removeMass(mass);\n\t      this.state.masses.push(mass);\n\t    }\n\t  }, {\n\t    key: \"removeMass\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Remove a particle for the masses array.\n\t     * @param  {Particle} mass\n\t     */\n\t    value: function removeMass(_ref) {\n\t      var mass = _ref.state;\n\t\n\t      var masses = this.state.masses;\n\t\n\t      for (var i = 0; i < masses.length; i++) {\n\t        if (mass.x === masses[i].state.x && mass.y === masses[i].state.y) {\n\t          masses.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: \"gravitateTo\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Applys gravitation to the input particle.\n\t     * @param  {Particle} particle\n\t     * @return {Object}\n\t     */\n\t    value: function gravitateTo(particle) {\n\t      var dx = particle.state.x - this.state.x;\n\t      var dy = particle.state.y - this.state.y;\n\t\n\t      // Distance between the two particles\n\t      // we dont use the distanceTo fn cause we want\n\t      // to optimzie the code to not have to calculate\n\t      // distSqrd again.\n\t      var distSqrd = dx * dx + dy * dy;\n\t      var dist = Math.sqrt(distSqrd);\n\t\n\t      // Magnitude of the vector [F = G(m1)(m2)/r^2]\n\t      var force = particle.state.mass / distSqrd;\n\t\n\t      // Setting up angles of the vector\n\t      var sin = dy / dist;\n\t      var cos = dx / dist;\n\t\n\t      // Setting vetor angle\n\t      var ax = cos * force;\n\t      var ay = sin * force;\n\t\n\t      return this.accelerate(ax, ay);\n\t    }\n\t  }, {\n\t    key: \"updatePos\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Apply velocity to the position.\n\t     * @param  {Integer} vx\n\t     * @param  {Integer} vy\n\t     * @return {void}\n\t     */\n\t    value: function updatePos(vx, vy) {\n\t      if (vx === undefined && vy === undefined) {\n\t        this.state.x += this.state.vx;\n\t        this.state.y += this.state.vy;\n\t        return { x: this.state.x, y: this.state.y };\n\t      }\n\t\n\t      this.state.x += vx;\n\t      this.state.y += vy;\n\t      return { x: this.state.x, y: this.state.y };\n\t    }\n\t  }, {\n\t    key: \"addSpring\",\n\t\n\t\n\t    /**\n\t     * @description add spring to springs array\n\t     * @memberOf Particle\n\t     * @param {Object} spring A spring object\n\t     * @return {Object}\n\t     */\n\t    value: function addSpring(spring) {\n\t      this.removeSpring(spring);\n\t      this.state.springs.push(spring);\n\t      return spring;\n\t    }\n\t  }, {\n\t    key: \"removeSpring\",\n\t\n\t\n\t    /**\n\t     * @description remove a specific string from the springs array\n\t     * @memberOf Particle\n\t     * @param  {Object} spring\n\t     */\n\t    value: function removeSpring(_ref2) {\n\t      var p = _ref2.point.state;\n\t\n\t      var springs = this.state.springs;\n\t\n\t      for (var i = 0; i < springs.length; i++) {\n\t        if (p.x === springs[i].point.state.x && p.y === springs[i].point.state.y) {\n\t          springs.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: \"springFromTo\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Given two particles calculate the\n\t     * spring force applied to both particles.\n\t     * @param  {Particle} particle\n\t     * @param  {Integer}  springy  Given offset for the particles\n\t     * @param  {Integer}  offset  The spring coefficent\n\t     * @return {Particle[]}\n\t     */\n\t    value: function springFromTo(particle) {\n\t      var springy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.05;\n\t      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n\t\n\t      // Postion delta\n\t      var dx = particle.state.x - this.state.x;\n\t      var dy = particle.state.y - this.state.y;\n\t\n\t      // Setting up magnitude and angle of the vector\n\t      var distance = Math.hypot(dx, dy);\n\t      var springForce = (distance - offset) * springy;\n\t\n\t      // Spring acceleration vector\n\t      var sx = dx / distance * springForce;\n\t      var sy = dy / distance * springForce;\n\t\n\t      // Accelerate with the spring vector\n\t      this.accelerate(sx, sy);\n\t\n\t      // Accelerate the opposite direction.\n\t      particle.state.vx -= sx;\n\t      particle.state.vy -= sy;\n\t\n\t      return [this, particle];\n\t    }\n\t  }, {\n\t    key: \"springToPoint\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Given a particle, a vector, and a spring coeffiencent accelerate\n\t     * the particle according to the distance its is from the point.\n\t     * @param  {Spring} spring A spring object.\n\t     * @return {Particle}\n\t     */\n\t    value: function springToPoint(spring) {\n\t      // Postion delta\n\t      var dx = spring.point.state.x - this.state.x;\n\t      var dy = spring.point.state.y - this.state.y;\n\t\n\t      // Setting up magnitude and angle of the vector\n\t      var distance = Math.hypot(dx, dy);\n\t      var springForce = (distance - spring.offset) * spring[\"spring\"];\n\t\n\t      // Spring acceleration vector\n\t      var sx = dx / distance * springForce;\n\t      var sy = dy / distance * springForce;\n\t\n\t      // Accelerate with the spring vector\n\t      this.accelerate(sx, sy);\n\t\n\t      return [this, spring];\n\t    }\n\t  }, {\n\t    key: \"handleSprings\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description Apply spring point to all internal springs.\n\t     * @param  {springs} springs An array of springs to spring to.\n\t     * @return {Object[]}\n\t     */\n\t    value: function handleSprings() {\n\t      var springs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.springs;\n\t\n\t      for (var i = 0; i < springs.length; i++) {\n\t        this.springToPoint(springs[i]);\n\t      }\n\t\n\t      return springs;\n\t    }\n\t  }, {\n\t    key: \"handleMasses\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description For each mass in the masses array apply gravitate to it.\n\t     * @param  {Particles[]|Object[]} masses\n\t     * @return {Particles[]|Object[]}\n\t     */\n\t    value: function handleMasses() {\n\t      var masses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.masses;\n\t\n\t      for (var i = 0; i < masses.length; i++) {\n\t        this.gravitateTo(masses[i]);\n\t      }\n\t\n\t      return masses;\n\t    }\n\t  }], [{\n\t    key: \"create\",\n\t\n\t\n\t    /**\n\t     * @description Create a particle given a direction and magnitude.\n\t     * @memberOf Particle\n\t     * @param  {Object}   state optional state values to pass to create.\n\t     * @return {Particle} returns a particle\n\t     */\n\t    value: function create() {\n\t      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : clone(INITIAL_STATE);\n\t\n\t      // Extend the optional state on to the default state.\n\t      state = extend(true, clone(INITIAL_STATE), state);\n\t\n\t      // Create particle with the new options.\n\t      var particle = new Particle(state);\n\t\n\t      // Set length.\n\t      particle.setSpeed(state.magnitude);\n\t\n\t      // Set angle.\n\t      particle.setHeading(state.direction);\n\t\n\t      // Return new particle.\n\t      return particle;\n\t    }\n\t  }, {\n\t    key: \"generate\",\n\t\n\t\n\t    /**\n\t     * @memberOf Particle\n\t     * @description generate a bunch of particles.\n\t     * @param  {Number} number    The maximum amount of generated particles needed.\n\t     * @param  {Object} opts      Options to pass each particle\n\t     * @return {Array<Particle>}\n\t     */\n\t    value: function generate(number) {\n\t      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : clone(INITIAL_STATE);\n\t\n\t      var particles = [];\n\t\n\t      for (var i = 0; i < number; i++) {\n\t        particles.push(Particle.create(opts));\n\t      }\n\t\n\t      return particles;\n\t    }\n\t  }]);\n\t\n\t  return Particle;\n\t}();\n\t\n\t;\n\t\n\tmodule.exports = Particle;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\t\n\tvar isArray = function isArray(arr) {\n\t\tif (typeof Array.isArray === 'function') {\n\t\t\treturn Array.isArray(arr);\n\t\t}\n\t\n\t\treturn toStr.call(arr) === '[object Array]';\n\t};\n\t\n\tvar isPlainObject = function isPlainObject(obj) {\n\t\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\t\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tvar key;\n\t\tfor (key in obj) {/**/}\n\t\n\t\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n\t};\n\t\n\tmodule.exports = function extend() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0],\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\t\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === 'boolean') {\n\t\t\tdeep = target;\n\t\t\ttarget = arguments[1] || {};\n\t\t\t// skip the boolean and the target\n\t\t\ti = 2;\n\t\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\t\ttarget = {};\n\t\t}\n\t\n\t\tfor (; i < length; ++i) {\n\t\t\toptions = arguments[i];\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif (options != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\t\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target !== copy) {\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\t\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseClone = __webpack_require__(7);\n\t\n\t/** Used to compose bitmasks for cloning. */\n\tvar CLONE_DEEP_FLAG = 1,\n\t    CLONE_SYMBOLS_FLAG = 4;\n\t\n\t/**\n\t * This method is like `_.clone` except that it recursively clones `value`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 1.0.0\n\t * @category Lang\n\t * @param {*} value The value to recursively clone.\n\t * @returns {*} Returns the deep cloned value.\n\t * @see _.clone\n\t * @example\n\t *\n\t * var objects = [{ 'a': 1 }, { 'b': 2 }];\n\t *\n\t * var deep = _.cloneDeep(objects);\n\t * console.log(deep[0] === objects[0]);\n\t * // => false\n\t */\n\tfunction cloneDeep(value) {\n\t  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n\t}\n\t\n\tmodule.exports = cloneDeep;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Stack = __webpack_require__(8),\n\t    arrayEach = __webpack_require__(52),\n\t    assignValue = __webpack_require__(53),\n\t    baseAssign = __webpack_require__(56),\n\t    baseAssignIn = __webpack_require__(79),\n\t    cloneBuffer = __webpack_require__(83),\n\t    copyArray = __webpack_require__(84),\n\t    copySymbols = __webpack_require__(85),\n\t    copySymbolsIn = __webpack_require__(89),\n\t    getAllKeys = __webpack_require__(93),\n\t    getAllKeysIn = __webpack_require__(95),\n\t    getTag = __webpack_require__(96),\n\t    initCloneArray = __webpack_require__(101),\n\t    initCloneByTag = __webpack_require__(102),\n\t    initCloneObject = __webpack_require__(116),\n\t    isArray = __webpack_require__(64),\n\t    isBuffer = __webpack_require__(65),\n\t    isObject = __webpack_require__(32),\n\t    keys = __webpack_require__(58);\n\t\n\t/** Used to compose bitmasks for cloning. */\n\tvar CLONE_DEEP_FLAG = 1,\n\t    CLONE_FLAT_FLAG = 2,\n\t    CLONE_SYMBOLS_FLAG = 4;\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]',\n\t    arrayTag = '[object Array]',\n\t    boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    errorTag = '[object Error]',\n\t    funcTag = '[object Function]',\n\t    genTag = '[object GeneratorFunction]',\n\t    mapTag = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    objectTag = '[object Object]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag = '[object Set]',\n\t    stringTag = '[object String]',\n\t    symbolTag = '[object Symbol]',\n\t    weakMapTag = '[object WeakMap]';\n\t\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    dataViewTag = '[object DataView]',\n\t    float32Tag = '[object Float32Array]',\n\t    float64Tag = '[object Float64Array]',\n\t    int8Tag = '[object Int8Array]',\n\t    int16Tag = '[object Int16Array]',\n\t    int32Tag = '[object Int32Array]',\n\t    uint8Tag = '[object Uint8Array]',\n\t    uint8ClampedTag = '[object Uint8ClampedArray]',\n\t    uint16Tag = '[object Uint16Array]',\n\t    uint32Tag = '[object Uint32Array]';\n\t\n\t/** Used to identify `toStringTag` values supported by `_.clone`. */\n\tvar cloneableTags = {};\n\tcloneableTags[argsTag] = cloneableTags[arrayTag] =\n\tcloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n\tcloneableTags[boolTag] = cloneableTags[dateTag] =\n\tcloneableTags[float32Tag] = cloneableTags[float64Tag] =\n\tcloneableTags[int8Tag] = cloneableTags[int16Tag] =\n\tcloneableTags[int32Tag] = cloneableTags[mapTag] =\n\tcloneableTags[numberTag] = cloneableTags[objectTag] =\n\tcloneableTags[regexpTag] = cloneableTags[setTag] =\n\tcloneableTags[stringTag] = cloneableTags[symbolTag] =\n\tcloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n\tcloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n\tcloneableTags[errorTag] = cloneableTags[funcTag] =\n\tcloneableTags[weakMapTag] = false;\n\t\n\t/**\n\t * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n\t * traversed objects.\n\t *\n\t * @private\n\t * @param {*} value The value to clone.\n\t * @param {boolean} bitmask The bitmask flags.\n\t *  1 - Deep clone\n\t *  2 - Flatten inherited properties\n\t *  4 - Clone symbols\n\t * @param {Function} [customizer] The function to customize cloning.\n\t * @param {string} [key] The key of `value`.\n\t * @param {Object} [object] The parent object of `value`.\n\t * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n\t * @returns {*} Returns the cloned value.\n\t */\n\tfunction baseClone(value, bitmask, customizer, key, object, stack) {\n\t  var result,\n\t      isDeep = bitmask & CLONE_DEEP_FLAG,\n\t      isFlat = bitmask & CLONE_FLAT_FLAG,\n\t      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\t\n\t  if (customizer) {\n\t    result = object ? customizer(value, key, object, stack) : customizer(value);\n\t  }\n\t  if (result !== undefined) {\n\t    return result;\n\t  }\n\t  if (!isObject(value)) {\n\t    return value;\n\t  }\n\t  var isArr = isArray(value);\n\t  if (isArr) {\n\t    result = initCloneArray(value);\n\t    if (!isDeep) {\n\t      return copyArray(value, result);\n\t    }\n\t  } else {\n\t    var tag = getTag(value),\n\t        isFunc = tag == funcTag || tag == genTag;\n\t\n\t    if (isBuffer(value)) {\n\t      return cloneBuffer(value, isDeep);\n\t    }\n\t    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n\t      if (!isDeep) {\n\t        return isFlat\n\t          ? copySymbolsIn(value, baseAssignIn(result, value))\n\t          : copySymbols(value, baseAssign(result, value));\n\t      }\n\t    } else {\n\t      if (!cloneableTags[tag]) {\n\t        return object ? value : {};\n\t      }\n\t      result = initCloneByTag(value, tag, baseClone, isDeep);\n\t    }\n\t  }\n\t  // Check for circular references and return its corresponding clone.\n\t  stack || (stack = new Stack);\n\t  var stacked = stack.get(value);\n\t  if (stacked) {\n\t    return stacked;\n\t  }\n\t  stack.set(value, result);\n\t\n\t  var keysFunc = isFull\n\t    ? (isFlat ? getAllKeysIn : getAllKeys)\n\t    : (isFlat ? keysIn : keys);\n\t\n\t  var props = isArr ? undefined : keysFunc(value);\n\t  arrayEach(props || value, function(subValue, key) {\n\t    if (props) {\n\t      key = subValue;\n\t      subValue = value[key];\n\t    }\n\t    // Recursively populate clone (susceptible to call stack limits).\n\t    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n\t  });\n\t  return result;\n\t}\n\t\n\tmodule.exports = baseClone;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ListCache = __webpack_require__(9),\n\t    stackClear = __webpack_require__(17),\n\t    stackDelete = __webpack_require__(18),\n\t    stackGet = __webpack_require__(19),\n\t    stackHas = __webpack_require__(20),\n\t    stackSet = __webpack_require__(21);\n\t\n\t/**\n\t * Creates a stack cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Stack(entries) {\n\t  var data = this.__data__ = new ListCache(entries);\n\t  this.size = data.size;\n\t}\n\t\n\t// Add methods to `Stack`.\n\tStack.prototype.clear = stackClear;\n\tStack.prototype['delete'] = stackDelete;\n\tStack.prototype.get = stackGet;\n\tStack.prototype.has = stackHas;\n\tStack.prototype.set = stackSet;\n\t\n\tmodule.exports = Stack;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar listCacheClear = __webpack_require__(10),\n\t    listCacheDelete = __webpack_require__(11),\n\t    listCacheGet = __webpack_require__(14),\n\t    listCacheHas = __webpack_require__(15),\n\t    listCacheSet = __webpack_require__(16);\n\t\n\t/**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction ListCache(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\t\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\t\n\t// Add methods to `ListCache`.\n\tListCache.prototype.clear = listCacheClear;\n\tListCache.prototype['delete'] = listCacheDelete;\n\tListCache.prototype.get = listCacheGet;\n\tListCache.prototype.has = listCacheHas;\n\tListCache.prototype.set = listCacheSet;\n\t\n\tmodule.exports = ListCache;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Removes all key-value entries from the list cache.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf ListCache\n\t */\n\tfunction listCacheClear() {\n\t  this.__data__ = [];\n\t  this.size = 0;\n\t}\n\t\n\tmodule.exports = listCacheClear;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(12);\n\t\n\t/** Used for built-in method references. */\n\tvar arrayProto = Array.prototype;\n\t\n\t/** Built-in value references. */\n\tvar splice = arrayProto.splice;\n\t\n\t/**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction listCacheDelete(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\t\n\t  if (index < 0) {\n\t    return false;\n\t  }\n\t  var lastIndex = data.length - 1;\n\t  if (index == lastIndex) {\n\t    data.pop();\n\t  } else {\n\t    splice.call(data, index, 1);\n\t  }\n\t  --this.size;\n\t  return true;\n\t}\n\t\n\tmodule.exports = listCacheDelete;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar eq = __webpack_require__(13);\n\t\n\t/**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction assocIndexOf(array, key) {\n\t  var length = array.length;\n\t  while (length--) {\n\t    if (eq(array[length][0], key)) {\n\t      return length;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tmodule.exports = assocIndexOf;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Performs a\n\t * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * comparison between two values to determine if they are equivalent.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t * var other = { 'a': 1 };\n\t *\n\t * _.eq(object, object);\n\t * // => true\n\t *\n\t * _.eq(object, other);\n\t * // => false\n\t *\n\t * _.eq('a', 'a');\n\t * // => true\n\t *\n\t * _.eq('a', Object('a'));\n\t * // => false\n\t *\n\t * _.eq(NaN, NaN);\n\t * // => true\n\t */\n\tfunction eq(value, other) {\n\t  return value === other || (value !== value && other !== other);\n\t}\n\t\n\tmodule.exports = eq;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(12);\n\t\n\t/**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction listCacheGet(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\t\n\t  return index < 0 ? undefined : data[index][1];\n\t}\n\t\n\tmodule.exports = listCacheGet;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(12);\n\t\n\t/**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction listCacheHas(key) {\n\t  return assocIndexOf(this.__data__, key) > -1;\n\t}\n\t\n\tmodule.exports = listCacheHas;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(12);\n\t\n\t/**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */\n\tfunction listCacheSet(key, value) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\t\n\t  if (index < 0) {\n\t    ++this.size;\n\t    data.push([key, value]);\n\t  } else {\n\t    data[index][1] = value;\n\t  }\n\t  return this;\n\t}\n\t\n\tmodule.exports = listCacheSet;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ListCache = __webpack_require__(9);\n\t\n\t/**\n\t * Removes all key-value entries from the stack.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Stack\n\t */\n\tfunction stackClear() {\n\t  this.__data__ = new ListCache;\n\t  this.size = 0;\n\t}\n\t\n\tmodule.exports = stackClear;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Removes `key` and its value from the stack.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction stackDelete(key) {\n\t  var data = this.__data__,\n\t      result = data['delete'](key);\n\t\n\t  this.size = data.size;\n\t  return result;\n\t}\n\t\n\tmodule.exports = stackDelete;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Gets the stack value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction stackGet(key) {\n\t  return this.__data__.get(key);\n\t}\n\t\n\tmodule.exports = stackGet;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if a stack value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Stack\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction stackHas(key) {\n\t  return this.__data__.has(key);\n\t}\n\t\n\tmodule.exports = stackHas;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ListCache = __webpack_require__(9),\n\t    Map = __webpack_require__(22),\n\t    MapCache = __webpack_require__(37);\n\t\n\t/** Used as the size to enable large array optimizations. */\n\tvar LARGE_ARRAY_SIZE = 200;\n\t\n\t/**\n\t * Sets the stack `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the stack cache instance.\n\t */\n\tfunction stackSet(key, value) {\n\t  var data = this.__data__;\n\t  if (data instanceof ListCache) {\n\t    var pairs = data.__data__;\n\t    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n\t      pairs.push([key, value]);\n\t      this.size = ++data.size;\n\t      return this;\n\t    }\n\t    data = this.__data__ = new MapCache(pairs);\n\t  }\n\t  data.set(key, value);\n\t  this.size = data.size;\n\t  return this;\n\t}\n\t\n\tmodule.exports = stackSet;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23),\n\t    root = __webpack_require__(28);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar Map = getNative(root, 'Map');\n\t\n\tmodule.exports = Map;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseIsNative = __webpack_require__(24),\n\t    getValue = __webpack_require__(36);\n\t\n\t/**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */\n\tfunction getNative(object, key) {\n\t  var value = getValue(object, key);\n\t  return baseIsNative(value) ? value : undefined;\n\t}\n\t\n\tmodule.exports = getNative;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isFunction = __webpack_require__(25),\n\t    isMasked = __webpack_require__(33),\n\t    isObject = __webpack_require__(32),\n\t    toSource = __webpack_require__(35);\n\t\n\t/**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */\n\tvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\t\n\t/** Used to detect host constructors (Safari). */\n\tvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype,\n\t    objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Used to detect if a method is native. */\n\tvar reIsNative = RegExp('^' +\n\t  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n\t  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\t\n\t/**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */\n\tfunction baseIsNative(value) {\n\t  if (!isObject(value) || isMasked(value)) {\n\t    return false;\n\t  }\n\t  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n\t  return pattern.test(toSource(value));\n\t}\n\t\n\tmodule.exports = baseIsNative;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(26),\n\t    isObject = __webpack_require__(32);\n\t\n\t/** `Object#toString` result references. */\n\tvar asyncTag = '[object AsyncFunction]',\n\t    funcTag = '[object Function]',\n\t    genTag = '[object GeneratorFunction]',\n\t    proxyTag = '[object Proxy]';\n\t\n\t/**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */\n\tfunction isFunction(value) {\n\t  if (!isObject(value)) {\n\t    return false;\n\t  }\n\t  // The use of `Object#toString` avoids issues with the `typeof` operator\n\t  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\t  var tag = baseGetTag(value);\n\t  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n\t}\n\t\n\tmodule.exports = isFunction;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(27),\n\t    getRawTag = __webpack_require__(30),\n\t    objectToString = __webpack_require__(31);\n\t\n\t/** `Object#toString` result references. */\n\tvar nullTag = '[object Null]',\n\t    undefinedTag = '[object Undefined]';\n\t\n\t/** Built-in value references. */\n\tvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\t\n\t/**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tfunction baseGetTag(value) {\n\t  if (value == null) {\n\t    return value === undefined ? undefinedTag : nullTag;\n\t  }\n\t  return (symToStringTag && symToStringTag in Object(value))\n\t    ? getRawTag(value)\n\t    : objectToString(value);\n\t}\n\t\n\tmodule.exports = baseGetTag;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar root = __webpack_require__(28);\n\t\n\t/** Built-in value references. */\n\tvar Symbol = root.Symbol;\n\t\n\tmodule.exports = Symbol;\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar freeGlobal = __webpack_require__(29);\n\t\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\t\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\t\n\tmodule.exports = root;\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\t\n\tmodule.exports = freeGlobal;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(27);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString = objectProto.toString;\n\t\n\t/** Built-in value references. */\n\tvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\t\n\t/**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */\n\tfunction getRawTag(value) {\n\t  var isOwn = hasOwnProperty.call(value, symToStringTag),\n\t      tag = value[symToStringTag];\n\t\n\t  try {\n\t    value[symToStringTag] = undefined;\n\t    var unmasked = true;\n\t  } catch (e) {}\n\t\n\t  var result = nativeObjectToString.call(value);\n\t  if (unmasked) {\n\t    if (isOwn) {\n\t      value[symToStringTag] = tag;\n\t    } else {\n\t      delete value[symToStringTag];\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = getRawTag;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString = objectProto.toString;\n\t\n\t/**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */\n\tfunction objectToString(value) {\n\t  return nativeObjectToString.call(value);\n\t}\n\t\n\tmodule.exports = objectToString;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  var type = typeof value;\n\t  return value != null && (type == 'object' || type == 'function');\n\t}\n\t\n\tmodule.exports = isObject;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar coreJsData = __webpack_require__(34);\n\t\n\t/** Used to detect methods masquerading as native. */\n\tvar maskSrcKey = (function() {\n\t  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n\t  return uid ? ('Symbol(src)_1.' + uid) : '';\n\t}());\n\t\n\t/**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */\n\tfunction isMasked(func) {\n\t  return !!maskSrcKey && (maskSrcKey in func);\n\t}\n\t\n\tmodule.exports = isMasked;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar root = __webpack_require__(28);\n\t\n\t/** Used to detect overreaching core-js shims. */\n\tvar coreJsData = root['__core-js_shared__'];\n\t\n\tmodule.exports = coreJsData;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\t\n\t/**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to convert.\n\t * @returns {string} Returns the source code.\n\t */\n\tfunction toSource(func) {\n\t  if (func != null) {\n\t    try {\n\t      return funcToString.call(func);\n\t    } catch (e) {}\n\t    try {\n\t      return (func + '');\n\t    } catch (e) {}\n\t  }\n\t  return '';\n\t}\n\t\n\tmodule.exports = toSource;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Gets the value at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} [object] The object to query.\n\t * @param {string} key The key of the property to get.\n\t * @returns {*} Returns the property value.\n\t */\n\tfunction getValue(object, key) {\n\t  return object == null ? undefined : object[key];\n\t}\n\t\n\tmodule.exports = getValue;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar mapCacheClear = __webpack_require__(38),\n\t    mapCacheDelete = __webpack_require__(46),\n\t    mapCacheGet = __webpack_require__(49),\n\t    mapCacheHas = __webpack_require__(50),\n\t    mapCacheSet = __webpack_require__(51);\n\t\n\t/**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction MapCache(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\t\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\t\n\t// Add methods to `MapCache`.\n\tMapCache.prototype.clear = mapCacheClear;\n\tMapCache.prototype['delete'] = mapCacheDelete;\n\tMapCache.prototype.get = mapCacheGet;\n\tMapCache.prototype.has = mapCacheHas;\n\tMapCache.prototype.set = mapCacheSet;\n\t\n\tmodule.exports = MapCache;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Hash = __webpack_require__(39),\n\t    ListCache = __webpack_require__(9),\n\t    Map = __webpack_require__(22);\n\t\n\t/**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */\n\tfunction mapCacheClear() {\n\t  this.size = 0;\n\t  this.__data__ = {\n\t    'hash': new Hash,\n\t    'map': new (Map || ListCache),\n\t    'string': new Hash\n\t  };\n\t}\n\t\n\tmodule.exports = mapCacheClear;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar hashClear = __webpack_require__(40),\n\t    hashDelete = __webpack_require__(42),\n\t    hashGet = __webpack_require__(43),\n\t    hashHas = __webpack_require__(44),\n\t    hashSet = __webpack_require__(45);\n\t\n\t/**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Hash(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\t\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\t\n\t// Add methods to `Hash`.\n\tHash.prototype.clear = hashClear;\n\tHash.prototype['delete'] = hashDelete;\n\tHash.prototype.get = hashGet;\n\tHash.prototype.has = hashHas;\n\tHash.prototype.set = hashSet;\n\t\n\tmodule.exports = Hash;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(41);\n\t\n\t/**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */\n\tfunction hashClear() {\n\t  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n\t  this.size = 0;\n\t}\n\t\n\tmodule.exports = hashClear;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar nativeCreate = getNative(Object, 'create');\n\t\n\tmodule.exports = nativeCreate;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Removes `key` and its value from the hash.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Hash\n\t * @param {Object} hash The hash to modify.\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction hashDelete(key) {\n\t  var result = this.has(key) && delete this.__data__[key];\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}\n\t\n\tmodule.exports = hashDelete;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(41);\n\t\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction hashGet(key) {\n\t  var data = this.__data__;\n\t  if (nativeCreate) {\n\t    var result = data[key];\n\t    return result === HASH_UNDEFINED ? undefined : result;\n\t  }\n\t  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n\t}\n\t\n\tmodule.exports = hashGet;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(41);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction hashHas(key) {\n\t  var data = this.__data__;\n\t  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n\t}\n\t\n\tmodule.exports = hashHas;\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(41);\n\t\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t/**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */\n\tfunction hashSet(key, value) {\n\t  var data = this.__data__;\n\t  this.size += this.has(key) ? 0 : 1;\n\t  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n\t  return this;\n\t}\n\t\n\tmodule.exports = hashSet;\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(47);\n\t\n\t/**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction mapCacheDelete(key) {\n\t  var result = getMapData(this, key)['delete'](key);\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}\n\t\n\tmodule.exports = mapCacheDelete;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isKeyable = __webpack_require__(48);\n\t\n\t/**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */\n\tfunction getMapData(map, key) {\n\t  var data = map.__data__;\n\t  return isKeyable(key)\n\t    ? data[typeof key == 'string' ? 'string' : 'hash']\n\t    : data.map;\n\t}\n\t\n\tmodule.exports = getMapData;\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is suitable for use as unique object key.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t */\n\tfunction isKeyable(value) {\n\t  var type = typeof value;\n\t  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n\t    ? (value !== '__proto__')\n\t    : (value === null);\n\t}\n\t\n\tmodule.exports = isKeyable;\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(47);\n\t\n\t/**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction mapCacheGet(key) {\n\t  return getMapData(this, key).get(key);\n\t}\n\t\n\tmodule.exports = mapCacheGet;\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(47);\n\t\n\t/**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction mapCacheHas(key) {\n\t  return getMapData(this, key).has(key);\n\t}\n\t\n\tmodule.exports = mapCacheHas;\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(47);\n\t\n\t/**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */\n\tfunction mapCacheSet(key, value) {\n\t  var data = getMapData(this, key),\n\t      size = data.size;\n\t\n\t  data.set(key, value);\n\t  this.size += data.size == size ? 0 : 1;\n\t  return this;\n\t}\n\t\n\tmodule.exports = mapCacheSet;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A specialized version of `_.forEach` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayEach(array, iteratee) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\t\n\t  while (++index < length) {\n\t    if (iteratee(array[index], index, array) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return array;\n\t}\n\t\n\tmodule.exports = arrayEach;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseAssignValue = __webpack_require__(54),\n\t    eq = __webpack_require__(13);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * for equality comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */\n\tfunction assignValue(object, key, value) {\n\t  var objValue = object[key];\n\t  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n\t      (value === undefined && !(key in object))) {\n\t    baseAssignValue(object, key, value);\n\t  }\n\t}\n\t\n\tmodule.exports = assignValue;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar defineProperty = __webpack_require__(55);\n\t\n\t/**\n\t * The base implementation of `assignValue` and `assignMergeValue` without\n\t * value checks.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */\n\tfunction baseAssignValue(object, key, value) {\n\t  if (key == '__proto__' && defineProperty) {\n\t    defineProperty(object, key, {\n\t      'configurable': true,\n\t      'enumerable': true,\n\t      'value': value,\n\t      'writable': true\n\t    });\n\t  } else {\n\t    object[key] = value;\n\t  }\n\t}\n\t\n\tmodule.exports = baseAssignValue;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23);\n\t\n\tvar defineProperty = (function() {\n\t  try {\n\t    var func = getNative(Object, 'defineProperty');\n\t    func({}, '', {});\n\t    return func;\n\t  } catch (e) {}\n\t}());\n\t\n\tmodule.exports = defineProperty;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar copyObject = __webpack_require__(57),\n\t    keys = __webpack_require__(58);\n\t\n\t/**\n\t * The base implementation of `_.assign` without support for multiple sources\n\t * or `customizer` functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseAssign(object, source) {\n\t  return object && copyObject(source, keys(source), object);\n\t}\n\t\n\tmodule.exports = baseAssign;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar assignValue = __webpack_require__(53),\n\t    baseAssignValue = __webpack_require__(54);\n\t\n\t/**\n\t * Copies properties of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy properties from.\n\t * @param {Array} props The property identifiers to copy.\n\t * @param {Object} [object={}] The object to copy properties to.\n\t * @param {Function} [customizer] The function to customize copied values.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction copyObject(source, props, object, customizer) {\n\t  var isNew = !object;\n\t  object || (object = {});\n\t\n\t  var index = -1,\n\t      length = props.length;\n\t\n\t  while (++index < length) {\n\t    var key = props[index];\n\t\n\t    var newValue = customizer\n\t      ? customizer(object[key], source[key], key, object, source)\n\t      : undefined;\n\t\n\t    if (newValue === undefined) {\n\t      newValue = source[key];\n\t    }\n\t    if (isNew) {\n\t      baseAssignValue(object, key, newValue);\n\t    } else {\n\t      assignValue(object, key, newValue);\n\t    }\n\t  }\n\t  return object;\n\t}\n\t\n\tmodule.exports = copyObject;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrayLikeKeys = __webpack_require__(59),\n\t    baseKeys = __webpack_require__(74),\n\t    isArrayLike = __webpack_require__(78);\n\t\n\t/**\n\t * Creates an array of the own enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects. See the\n\t * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t * for more details.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keys(new Foo);\n\t * // => ['a', 'b'] (iteration order is not guaranteed)\n\t *\n\t * _.keys('hi');\n\t * // => ['0', '1']\n\t */\n\tfunction keys(object) {\n\t  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n\t}\n\t\n\tmodule.exports = keys;\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseTimes = __webpack_require__(60),\n\t    isArguments = __webpack_require__(61),\n\t    isArray = __webpack_require__(64),\n\t    isBuffer = __webpack_require__(65),\n\t    isIndex = __webpack_require__(68),\n\t    isTypedArray = __webpack_require__(69);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Creates an array of the enumerable property names of the array-like `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @param {boolean} inherited Specify returning inherited property names.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction arrayLikeKeys(value, inherited) {\n\t  var isArr = isArray(value),\n\t      isArg = !isArr && isArguments(value),\n\t      isBuff = !isArr && !isArg && isBuffer(value),\n\t      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n\t      skipIndexes = isArr || isArg || isBuff || isType,\n\t      result = skipIndexes ? baseTimes(value.length, String) : [],\n\t      length = result.length;\n\t\n\t  for (var key in value) {\n\t    if ((inherited || hasOwnProperty.call(value, key)) &&\n\t        !(skipIndexes && (\n\t           // Safari 9 has enumerable `arguments.length` in strict mode.\n\t           key == 'length' ||\n\t           // Node.js 0.10 has enumerable non-index properties on buffers.\n\t           (isBuff && (key == 'offset' || key == 'parent')) ||\n\t           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n\t           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n\t           // Skip index properties.\n\t           isIndex(key, length)\n\t        ))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = arrayLikeKeys;\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t/**\n\t * The base implementation of `_.times` without support for iteratee shorthands\n\t * or max array length checks.\n\t *\n\t * @private\n\t * @param {number} n The number of times to invoke `iteratee`.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the array of results.\n\t */\n\tfunction baseTimes(n, iteratee) {\n\t  var index = -1,\n\t      result = Array(n);\n\t\n\t  while (++index < n) {\n\t    result[index] = iteratee(index);\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = baseTimes;\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseIsArguments = __webpack_require__(62),\n\t    isObjectLike = __webpack_require__(63);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\t\n\t/**\n\t * Checks if `value` is likely an `arguments` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t *  else `false`.\n\t * @example\n\t *\n\t * _.isArguments(function() { return arguments; }());\n\t * // => true\n\t *\n\t * _.isArguments([1, 2, 3]);\n\t * // => false\n\t */\n\tvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n\t  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n\t    !propertyIsEnumerable.call(value, 'callee');\n\t};\n\t\n\tmodule.exports = isArguments;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(26),\n\t    isObjectLike = __webpack_require__(63);\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]';\n\t\n\t/**\n\t * The base implementation of `_.isArguments`.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t */\n\tfunction baseIsArguments(value) {\n\t  return isObjectLike(value) && baseGetTag(value) == argsTag;\n\t}\n\t\n\tmodule.exports = baseIsArguments;\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return value != null && typeof value == 'object';\n\t}\n\t\n\tmodule.exports = isObjectLike;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Checks if `value` is classified as an `Array` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n\t * @example\n\t *\n\t * _.isArray([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArray(document.body.children);\n\t * // => false\n\t *\n\t * _.isArray('abc');\n\t * // => false\n\t *\n\t * _.isArray(_.noop);\n\t * // => false\n\t */\n\tvar isArray = Array.isArray;\n\t\n\tmodule.exports = isArray;\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(28),\n\t    stubFalse = __webpack_require__(67);\n\t\n\t/** Detect free variable `exports`. */\n\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\t\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\t\n\t/** Built-in value references. */\n\tvar Buffer = moduleExports ? root.Buffer : undefined;\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\t\n\t/**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */\n\tvar isBuffer = nativeIsBuffer || stubFalse;\n\t\n\tmodule.exports = isBuffer;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)(module)))\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This method returns `false`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {boolean} Returns `false`.\n\t * @example\n\t *\n\t * _.times(2, _.stubFalse);\n\t * // => [false, false]\n\t */\n\tfunction stubFalse() {\n\t  return false;\n\t}\n\t\n\tmodule.exports = stubFalse;\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports) {\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t/** Used to detect unsigned integer values. */\n\tvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  length = length == null ? MAX_SAFE_INTEGER : length;\n\t  return !!length &&\n\t    (typeof value == 'number' || reIsUint.test(value)) &&\n\t    (value > -1 && value % 1 == 0 && value < length);\n\t}\n\t\n\tmodule.exports = isIndex;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseIsTypedArray = __webpack_require__(70),\n\t    baseUnary = __webpack_require__(72),\n\t    nodeUtil = __webpack_require__(73);\n\t\n\t/* Node.js helper references. */\n\tvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\t\n\t/**\n\t * Checks if `value` is classified as a typed array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t * @example\n\t *\n\t * _.isTypedArray(new Uint8Array);\n\t * // => true\n\t *\n\t * _.isTypedArray([]);\n\t * // => false\n\t */\n\tvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\t\n\tmodule.exports = isTypedArray;\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(26),\n\t    isLength = __webpack_require__(71),\n\t    isObjectLike = __webpack_require__(63);\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]',\n\t    arrayTag = '[object Array]',\n\t    boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    errorTag = '[object Error]',\n\t    funcTag = '[object Function]',\n\t    mapTag = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    objectTag = '[object Object]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag = '[object Set]',\n\t    stringTag = '[object String]',\n\t    weakMapTag = '[object WeakMap]';\n\t\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    dataViewTag = '[object DataView]',\n\t    float32Tag = '[object Float32Array]',\n\t    float64Tag = '[object Float64Array]',\n\t    int8Tag = '[object Int8Array]',\n\t    int16Tag = '[object Int16Array]',\n\t    int32Tag = '[object Int32Array]',\n\t    uint8Tag = '[object Uint8Array]',\n\t    uint8ClampedTag = '[object Uint8ClampedArray]',\n\t    uint16Tag = '[object Uint16Array]',\n\t    uint32Tag = '[object Uint32Array]';\n\t\n\t/** Used to identify `toStringTag` values of typed arrays. */\n\tvar typedArrayTags = {};\n\ttypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\ttypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\ttypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\ttypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\ttypedArrayTags[uint32Tag] = true;\n\ttypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\ttypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\ttypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n\ttypedArrayTags[errorTag] = typedArrayTags[funcTag] =\n\ttypedArrayTags[mapTag] = typedArrayTags[numberTag] =\n\ttypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n\ttypedArrayTags[setTag] = typedArrayTags[stringTag] =\n\ttypedArrayTags[weakMapTag] = false;\n\t\n\t/**\n\t * The base implementation of `_.isTypedArray` without Node.js optimizations.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t */\n\tfunction baseIsTypedArray(value) {\n\t  return isObjectLike(value) &&\n\t    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n\t}\n\t\n\tmodule.exports = baseIsTypedArray;\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports) {\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This method is loosely based on\n\t * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t * @example\n\t *\n\t * _.isLength(3);\n\t * // => true\n\t *\n\t * _.isLength(Number.MIN_VALUE);\n\t * // => false\n\t *\n\t * _.isLength(Infinity);\n\t * // => false\n\t *\n\t * _.isLength('3');\n\t * // => false\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' &&\n\t    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\tmodule.exports = isLength;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\t/**\n\t * The base implementation of `_.unary` without support for storing metadata.\n\t *\n\t * @private\n\t * @param {Function} func The function to cap arguments for.\n\t * @returns {Function} Returns the new capped function.\n\t */\n\tfunction baseUnary(func) {\n\t  return function(value) {\n\t    return func(value);\n\t  };\n\t}\n\t\n\tmodule.exports = baseUnary;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(29);\n\t\n\t/** Detect free variable `exports`. */\n\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\t\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\t\n\t/** Detect free variable `process` from Node.js. */\n\tvar freeProcess = moduleExports && freeGlobal.process;\n\t\n\t/** Used to access faster Node.js helpers. */\n\tvar nodeUtil = (function() {\n\t  try {\n\t    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n\t  } catch (e) {}\n\t}());\n\t\n\tmodule.exports = nodeUtil;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)(module)))\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isPrototype = __webpack_require__(75),\n\t    nativeKeys = __webpack_require__(76);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction baseKeys(object) {\n\t  if (!isPrototype(object)) {\n\t    return nativeKeys(object);\n\t  }\n\t  var result = [];\n\t  for (var key in Object(object)) {\n\t    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = baseKeys;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Checks if `value` is likely a prototype object.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t */\n\tfunction isPrototype(value) {\n\t  var Ctor = value && value.constructor,\n\t      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\t\n\t  return value === proto;\n\t}\n\t\n\tmodule.exports = isPrototype;\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar overArg = __webpack_require__(77);\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeKeys = overArg(Object.keys, Object);\n\t\n\tmodule.exports = nativeKeys;\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Creates a unary function that invokes `func` with its argument transformed.\n\t *\n\t * @private\n\t * @param {Function} func The function to wrap.\n\t * @param {Function} transform The argument transform.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction overArg(func, transform) {\n\t  return function(arg) {\n\t    return func(transform(arg));\n\t  };\n\t}\n\t\n\tmodule.exports = overArg;\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isFunction = __webpack_require__(25),\n\t    isLength = __webpack_require__(71);\n\t\n\t/**\n\t * Checks if `value` is array-like. A value is considered array-like if it's\n\t * not a function and has a `value.length` that's an integer greater than or\n\t * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t * @example\n\t *\n\t * _.isArrayLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArrayLike(document.body.children);\n\t * // => true\n\t *\n\t * _.isArrayLike('abc');\n\t * // => true\n\t *\n\t * _.isArrayLike(_.noop);\n\t * // => false\n\t */\n\tfunction isArrayLike(value) {\n\t  return value != null && isLength(value.length) && !isFunction(value);\n\t}\n\t\n\tmodule.exports = isArrayLike;\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar copyObject = __webpack_require__(57),\n\t    keysIn = __webpack_require__(80);\n\t\n\t/**\n\t * The base implementation of `_.assignIn` without support for multiple sources\n\t * or `customizer` functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseAssignIn(object, source) {\n\t  return object && copyObject(source, keysIn(source), object);\n\t}\n\t\n\tmodule.exports = baseAssignIn;\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrayLikeKeys = __webpack_require__(59),\n\t    baseKeysIn = __webpack_require__(81),\n\t    isArrayLike = __webpack_require__(78);\n\t\n\t/**\n\t * Creates an array of the own and inherited enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keysIn(new Foo);\n\t * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t */\n\tfunction keysIn(object) {\n\t  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n\t}\n\t\n\tmodule.exports = keysIn;\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(32),\n\t    isPrototype = __webpack_require__(75),\n\t    nativeKeysIn = __webpack_require__(82);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction baseKeysIn(object) {\n\t  if (!isObject(object)) {\n\t    return nativeKeysIn(object);\n\t  }\n\t  var isProto = isPrototype(object),\n\t      result = [];\n\t\n\t  for (var key in object) {\n\t    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = baseKeysIn;\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This function is like\n\t * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t * except that it includes inherited enumerable properties.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction nativeKeysIn(object) {\n\t  var result = [];\n\t  if (object != null) {\n\t    for (var key in Object(object)) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = nativeKeysIn;\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(28);\n\t\n\t/** Detect free variable `exports`. */\n\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\t\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\t\n\t/** Built-in value references. */\n\tvar Buffer = moduleExports ? root.Buffer : undefined,\n\t    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\t\n\t/**\n\t * Creates a clone of  `buffer`.\n\t *\n\t * @private\n\t * @param {Buffer} buffer The buffer to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Buffer} Returns the cloned buffer.\n\t */\n\tfunction cloneBuffer(buffer, isDeep) {\n\t  if (isDeep) {\n\t    return buffer.slice();\n\t  }\n\t  var length = buffer.length,\n\t      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\t\n\t  buffer.copy(result);\n\t  return result;\n\t}\n\t\n\tmodule.exports = cloneBuffer;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)(module)))\n\n/***/ },\n/* 84 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copies the values of `source` to `array`.\n\t *\n\t * @private\n\t * @param {Array} source The array to copy values from.\n\t * @param {Array} [array=[]] The array to copy values to.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction copyArray(source, array) {\n\t  var index = -1,\n\t      length = source.length;\n\t\n\t  array || (array = Array(length));\n\t  while (++index < length) {\n\t    array[index] = source[index];\n\t  }\n\t  return array;\n\t}\n\t\n\tmodule.exports = copyArray;\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar copyObject = __webpack_require__(57),\n\t    getSymbols = __webpack_require__(86);\n\t\n\t/**\n\t * Copies own symbols of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy symbols from.\n\t * @param {Object} [object={}] The object to copy symbols to.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction copySymbols(source, object) {\n\t  return copyObject(source, getSymbols(source), object);\n\t}\n\t\n\tmodule.exports = copySymbols;\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrayFilter = __webpack_require__(87),\n\t    stubArray = __webpack_require__(88);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\t\n\t/**\n\t * Creates an array of the own enumerable symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  object = Object(object);\n\t  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n\t    return propertyIsEnumerable.call(object, symbol);\n\t  });\n\t};\n\t\n\tmodule.exports = getSymbols;\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A specialized version of `_.filter` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @returns {Array} Returns the new filtered array.\n\t */\n\tfunction arrayFilter(array, predicate) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length,\n\t      resIndex = 0,\n\t      result = [];\n\t\n\t  while (++index < length) {\n\t    var value = array[index];\n\t    if (predicate(value, index, array)) {\n\t      result[resIndex++] = value;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = arrayFilter;\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This method returns a new empty array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {Array} Returns the new empty array.\n\t * @example\n\t *\n\t * var arrays = _.times(2, _.stubArray);\n\t *\n\t * console.log(arrays);\n\t * // => [[], []]\n\t *\n\t * console.log(arrays[0] === arrays[1]);\n\t * // => false\n\t */\n\tfunction stubArray() {\n\t  return [];\n\t}\n\t\n\tmodule.exports = stubArray;\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar copyObject = __webpack_require__(57),\n\t    getSymbolsIn = __webpack_require__(90);\n\t\n\t/**\n\t * Copies own and inherited symbols of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy symbols from.\n\t * @param {Object} [object={}] The object to copy symbols to.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction copySymbolsIn(source, object) {\n\t  return copyObject(source, getSymbolsIn(source), object);\n\t}\n\t\n\tmodule.exports = copySymbolsIn;\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrayPush = __webpack_require__(91),\n\t    getPrototype = __webpack_require__(92),\n\t    getSymbols = __webpack_require__(86),\n\t    stubArray = __webpack_require__(88);\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\t\n\t/**\n\t * Creates an array of the own and inherited enumerable symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n\t  var result = [];\n\t  while (object) {\n\t    arrayPush(result, getSymbols(object));\n\t    object = getPrototype(object);\n\t  }\n\t  return result;\n\t};\n\t\n\tmodule.exports = getSymbolsIn;\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Appends the elements of `values` to `array`.\n\t *\n\t * @private\n\t * @param {Array} array The array to modify.\n\t * @param {Array} values The values to append.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayPush(array, values) {\n\t  var index = -1,\n\t      length = values.length,\n\t      offset = array.length;\n\t\n\t  while (++index < length) {\n\t    array[offset + index] = values[index];\n\t  }\n\t  return array;\n\t}\n\t\n\tmodule.exports = arrayPush;\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar overArg = __webpack_require__(77);\n\t\n\t/** Built-in value references. */\n\tvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\t\n\tmodule.exports = getPrototype;\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseGetAllKeys = __webpack_require__(94),\n\t    getSymbols = __webpack_require__(86),\n\t    keys = __webpack_require__(58);\n\t\n\t/**\n\t * Creates an array of own enumerable property names and symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction getAllKeys(object) {\n\t  return baseGetAllKeys(object, keys, getSymbols);\n\t}\n\t\n\tmodule.exports = getAllKeys;\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar arrayPush = __webpack_require__(91),\n\t    isArray = __webpack_require__(64);\n\t\n\t/**\n\t * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n\t * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n\t * symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @param {Function} symbolsFunc The function to get the symbols of `object`.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n\t  var result = keysFunc(object);\n\t  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n\t}\n\t\n\tmodule.exports = baseGetAllKeys;\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseGetAllKeys = __webpack_require__(94),\n\t    getSymbolsIn = __webpack_require__(90),\n\t    keysIn = __webpack_require__(80);\n\t\n\t/**\n\t * Creates an array of own and inherited enumerable property names and\n\t * symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction getAllKeysIn(object) {\n\t  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n\t}\n\t\n\tmodule.exports = getAllKeysIn;\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DataView = __webpack_require__(97),\n\t    Map = __webpack_require__(22),\n\t    Promise = __webpack_require__(98),\n\t    Set = __webpack_require__(99),\n\t    WeakMap = __webpack_require__(100),\n\t    baseGetTag = __webpack_require__(26),\n\t    toSource = __webpack_require__(35);\n\t\n\t/** `Object#toString` result references. */\n\tvar mapTag = '[object Map]',\n\t    objectTag = '[object Object]',\n\t    promiseTag = '[object Promise]',\n\t    setTag = '[object Set]',\n\t    weakMapTag = '[object WeakMap]';\n\t\n\tvar dataViewTag = '[object DataView]';\n\t\n\t/** Used to detect maps, sets, and weakmaps. */\n\tvar dataViewCtorString = toSource(DataView),\n\t    mapCtorString = toSource(Map),\n\t    promiseCtorString = toSource(Promise),\n\t    setCtorString = toSource(Set),\n\t    weakMapCtorString = toSource(WeakMap);\n\t\n\t/**\n\t * Gets the `toStringTag` of `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tvar getTag = baseGetTag;\n\t\n\t// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\tif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n\t    (Map && getTag(new Map) != mapTag) ||\n\t    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n\t    (Set && getTag(new Set) != setTag) ||\n\t    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n\t  getTag = function(value) {\n\t    var result = baseGetTag(value),\n\t        Ctor = result == objectTag ? value.constructor : undefined,\n\t        ctorString = Ctor ? toSource(Ctor) : '';\n\t\n\t    if (ctorString) {\n\t      switch (ctorString) {\n\t        case dataViewCtorString: return dataViewTag;\n\t        case mapCtorString: return mapTag;\n\t        case promiseCtorString: return promiseTag;\n\t        case setCtorString: return setTag;\n\t        case weakMapCtorString: return weakMapTag;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t}\n\t\n\tmodule.exports = getTag;\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23),\n\t    root = __webpack_require__(28);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar DataView = getNative(root, 'DataView');\n\t\n\tmodule.exports = DataView;\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23),\n\t    root = __webpack_require__(28);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar Promise = getNative(root, 'Promise');\n\t\n\tmodule.exports = Promise;\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23),\n\t    root = __webpack_require__(28);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar Set = getNative(root, 'Set');\n\t\n\tmodule.exports = Set;\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(23),\n\t    root = __webpack_require__(28);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar WeakMap = getNative(root, 'WeakMap');\n\t\n\tmodule.exports = WeakMap;\n\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Initializes an array clone.\n\t *\n\t * @private\n\t * @param {Array} array The array to clone.\n\t * @returns {Array} Returns the initialized clone.\n\t */\n\tfunction initCloneArray(array) {\n\t  var length = array.length,\n\t      result = array.constructor(length);\n\t\n\t  // Add properties assigned by `RegExp#exec`.\n\t  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t    result.index = array.index;\n\t    result.input = array.input;\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = initCloneArray;\n\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cloneArrayBuffer = __webpack_require__(103),\n\t    cloneDataView = __webpack_require__(105),\n\t    cloneMap = __webpack_require__(106),\n\t    cloneRegExp = __webpack_require__(110),\n\t    cloneSet = __webpack_require__(111),\n\t    cloneSymbol = __webpack_require__(114),\n\t    cloneTypedArray = __webpack_require__(115);\n\t\n\t/** `Object#toString` result references. */\n\tvar boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    mapTag = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag = '[object Set]',\n\t    stringTag = '[object String]',\n\t    symbolTag = '[object Symbol]';\n\t\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    dataViewTag = '[object DataView]',\n\t    float32Tag = '[object Float32Array]',\n\t    float64Tag = '[object Float64Array]',\n\t    int8Tag = '[object Int8Array]',\n\t    int16Tag = '[object Int16Array]',\n\t    int32Tag = '[object Int32Array]',\n\t    uint8Tag = '[object Uint8Array]',\n\t    uint8ClampedTag = '[object Uint8ClampedArray]',\n\t    uint16Tag = '[object Uint16Array]',\n\t    uint32Tag = '[object Uint32Array]';\n\t\n\t/**\n\t * Initializes an object clone based on its `toStringTag`.\n\t *\n\t * **Note:** This function only supports cloning values with tags of\n\t * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t *\n\t * @private\n\t * @param {Object} object The object to clone.\n\t * @param {string} tag The `toStringTag` of the object to clone.\n\t * @param {Function} cloneFunc The function to clone values.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the initialized clone.\n\t */\n\tfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n\t  var Ctor = object.constructor;\n\t  switch (tag) {\n\t    case arrayBufferTag:\n\t      return cloneArrayBuffer(object);\n\t\n\t    case boolTag:\n\t    case dateTag:\n\t      return new Ctor(+object);\n\t\n\t    case dataViewTag:\n\t      return cloneDataView(object, isDeep);\n\t\n\t    case float32Tag: case float64Tag:\n\t    case int8Tag: case int16Tag: case int32Tag:\n\t    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n\t      return cloneTypedArray(object, isDeep);\n\t\n\t    case mapTag:\n\t      return cloneMap(object, isDeep, cloneFunc);\n\t\n\t    case numberTag:\n\t    case stringTag:\n\t      return new Ctor(object);\n\t\n\t    case regexpTag:\n\t      return cloneRegExp(object);\n\t\n\t    case setTag:\n\t      return cloneSet(object, isDeep, cloneFunc);\n\t\n\t    case symbolTag:\n\t      return cloneSymbol(object);\n\t  }\n\t}\n\t\n\tmodule.exports = initCloneByTag;\n\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Uint8Array = __webpack_require__(104);\n\t\n\t/**\n\t * Creates a clone of `arrayBuffer`.\n\t *\n\t * @private\n\t * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n\t * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t */\n\tfunction cloneArrayBuffer(arrayBuffer) {\n\t  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n\t  return result;\n\t}\n\t\n\tmodule.exports = cloneArrayBuffer;\n\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar root = __webpack_require__(28);\n\t\n\t/** Built-in value references. */\n\tvar Uint8Array = root.Uint8Array;\n\t\n\tmodule.exports = Uint8Array;\n\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cloneArrayBuffer = __webpack_require__(103);\n\t\n\t/**\n\t * Creates a clone of `dataView`.\n\t *\n\t * @private\n\t * @param {Object} dataView The data view to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the cloned data view.\n\t */\n\tfunction cloneDataView(dataView, isDeep) {\n\t  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n\t  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n\t}\n\t\n\tmodule.exports = cloneDataView;\n\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar addMapEntry = __webpack_require__(107),\n\t    arrayReduce = __webpack_require__(108),\n\t    mapToArray = __webpack_require__(109);\n\t\n\t/** Used to compose bitmasks for cloning. */\n\tvar CLONE_DEEP_FLAG = 1;\n\t\n\t/**\n\t * Creates a clone of `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to clone.\n\t * @param {Function} cloneFunc The function to clone values.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the cloned map.\n\t */\n\tfunction cloneMap(map, isDeep, cloneFunc) {\n\t  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n\t  return arrayReduce(array, addMapEntry, new map.constructor);\n\t}\n\t\n\tmodule.exports = cloneMap;\n\n\n/***/ },\n/* 107 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Adds the key-value `pair` to `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to modify.\n\t * @param {Array} pair The key-value pair to add.\n\t * @returns {Object} Returns `map`.\n\t */\n\tfunction addMapEntry(map, pair) {\n\t  // Don't return `map.set` because it's not chainable in IE 11.\n\t  map.set(pair[0], pair[1]);\n\t  return map;\n\t}\n\t\n\tmodule.exports = addMapEntry;\n\n\n/***/ },\n/* 108 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A specialized version of `_.reduce` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {*} [accumulator] The initial value.\n\t * @param {boolean} [initAccum] Specify using the first element of `array` as\n\t *  the initial value.\n\t * @returns {*} Returns the accumulated value.\n\t */\n\tfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\t\n\t  if (initAccum && length) {\n\t    accumulator = array[++index];\n\t  }\n\t  while (++index < length) {\n\t    accumulator = iteratee(accumulator, array[index], index, array);\n\t  }\n\t  return accumulator;\n\t}\n\t\n\tmodule.exports = arrayReduce;\n\n\n/***/ },\n/* 109 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Converts `map` to its key-value pairs.\n\t *\n\t * @private\n\t * @param {Object} map The map to convert.\n\t * @returns {Array} Returns the key-value pairs.\n\t */\n\tfunction mapToArray(map) {\n\t  var index = -1,\n\t      result = Array(map.size);\n\t\n\t  map.forEach(function(value, key) {\n\t    result[++index] = [key, value];\n\t  });\n\t  return result;\n\t}\n\t\n\tmodule.exports = mapToArray;\n\n\n/***/ },\n/* 110 */\n/***/ function(module, exports) {\n\n\t/** Used to match `RegExp` flags from their coerced string values. */\n\tvar reFlags = /\\w*$/;\n\t\n\t/**\n\t * Creates a clone of `regexp`.\n\t *\n\t * @private\n\t * @param {Object} regexp The regexp to clone.\n\t * @returns {Object} Returns the cloned regexp.\n\t */\n\tfunction cloneRegExp(regexp) {\n\t  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n\t  result.lastIndex = regexp.lastIndex;\n\t  return result;\n\t}\n\t\n\tmodule.exports = cloneRegExp;\n\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar addSetEntry = __webpack_require__(112),\n\t    arrayReduce = __webpack_require__(108),\n\t    setToArray = __webpack_require__(113);\n\t\n\t/** Used to compose bitmasks for cloning. */\n\tvar CLONE_DEEP_FLAG = 1;\n\t\n\t/**\n\t * Creates a clone of `set`.\n\t *\n\t * @private\n\t * @param {Object} set The set to clone.\n\t * @param {Function} cloneFunc The function to clone values.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the cloned set.\n\t */\n\tfunction cloneSet(set, isDeep, cloneFunc) {\n\t  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n\t  return arrayReduce(array, addSetEntry, new set.constructor);\n\t}\n\t\n\tmodule.exports = cloneSet;\n\n\n/***/ },\n/* 112 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Adds `value` to `set`.\n\t *\n\t * @private\n\t * @param {Object} set The set to modify.\n\t * @param {*} value The value to add.\n\t * @returns {Object} Returns `set`.\n\t */\n\tfunction addSetEntry(set, value) {\n\t  // Don't return `set.add` because it's not chainable in IE 11.\n\t  set.add(value);\n\t  return set;\n\t}\n\t\n\tmodule.exports = addSetEntry;\n\n\n/***/ },\n/* 113 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Converts `set` to an array of its values.\n\t *\n\t * @private\n\t * @param {Object} set The set to convert.\n\t * @returns {Array} Returns the values.\n\t */\n\tfunction setToArray(set) {\n\t  var index = -1,\n\t      result = Array(set.size);\n\t\n\t  set.forEach(function(value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\t\n\tmodule.exports = setToArray;\n\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(27);\n\t\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol ? Symbol.prototype : undefined,\n\t    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\t\n\t/**\n\t * Creates a clone of the `symbol` object.\n\t *\n\t * @private\n\t * @param {Object} symbol The symbol object to clone.\n\t * @returns {Object} Returns the cloned symbol object.\n\t */\n\tfunction cloneSymbol(symbol) {\n\t  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n\t}\n\t\n\tmodule.exports = cloneSymbol;\n\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cloneArrayBuffer = __webpack_require__(103);\n\t\n\t/**\n\t * Creates a clone of `typedArray`.\n\t *\n\t * @private\n\t * @param {Object} typedArray The typed array to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the cloned typed array.\n\t */\n\tfunction cloneTypedArray(typedArray, isDeep) {\n\t  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t}\n\t\n\tmodule.exports = cloneTypedArray;\n\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar baseCreate = __webpack_require__(117),\n\t    getPrototype = __webpack_require__(92),\n\t    isPrototype = __webpack_require__(75);\n\t\n\t/**\n\t * Initializes an object clone.\n\t *\n\t * @private\n\t * @param {Object} object The object to clone.\n\t * @returns {Object} Returns the initialized clone.\n\t */\n\tfunction initCloneObject(object) {\n\t  return (typeof object.constructor == 'function' && !isPrototype(object))\n\t    ? baseCreate(getPrototype(object))\n\t    : {};\n\t}\n\t\n\tmodule.exports = initCloneObject;\n\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(32);\n\t\n\t/** Built-in value references. */\n\tvar objectCreate = Object.create;\n\t\n\t/**\n\t * The base implementation of `_.create` without support for assigning\n\t * properties to the created object.\n\t *\n\t * @private\n\t * @param {Object} proto The object to inherit from.\n\t * @returns {Object} Returns the new object.\n\t */\n\tvar baseCreate = (function() {\n\t  function object() {}\n\t  return function(proto) {\n\t    if (!isObject(proto)) {\n\t      return {};\n\t    }\n\t    if (objectCreate) {\n\t      return objectCreate(proto);\n\t    }\n\t    object.prototype = proto;\n\t    var result = new object;\n\t    object.prototype = undefined;\n\t    return result;\n\t  };\n\t}());\n\t\n\tmodule.exports = baseCreate;\n\n\n/***/ },\n/* 118 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* eslint max-len: 0 */\n\t\n\t//      \n\t\n\t\n\t/**\n\t * @class Shapes\n\t * @param {Object} ctx      Canvas context.\n\t * @param {Object} document The document object.\n\t*/\n\tvar Shapes = function () {\n\t\n\t  /**\n\t   * constructor\n\t   * @param  {HTMLCanvasElement} ctx\n\t   * @param  {Document} document\n\t   */\n\t  function Shapes(ctx, document) {\n\t    _classCallCheck(this, Shapes);\n\t\n\t    if (!ctx) {\n\t      throw new Error(\"Shapes: Please provide a context argument [arg::1]\");\n\t    }\n\t\n\t    this.ctx = ctx;\n\t    this.document = document || window.document;\n\t  }\n\t\n\t  /**\n\t   * @memberOf Shapes\n\t   * @description draw a circle.\n\t   * @param {Number} x     The x coordinate of the circle.\n\t   * @param {Number} y     The y coordinate of the circle.\n\t   * @param {Number} r     The radius of the circle.\n\t   * @param {String} color The color of the circle.\n\t   */\n\t\n\t\n\t  _createClass(Shapes, [{\n\t    key: \"circle\",\n\t    value: function circle() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n\t      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n\t      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"#000000\";\n\t\n\t      this.ctx.fillStyle = color;\n\t      this.ctx.beginPath();\n\t      this.ctx.arc(x, y, r, 0, Math.PI * 2, false);\n\t      this.ctx.fill();\n\t    }\n\t  }, {\n\t    key: \"rect\",\n\t\n\t\n\t    /**\n\t     * @memberOf Shapes\n\t     * @description Fill a rectangle\n\t     * @param  {Number} x     Starting point X\n\t     * @param  {Number} y     Starting point Y\n\t     * @param  {Number} w     Width of the rectangle\n\t     * @param  {Number} h     Height of the rectangle\n\t     * @param  {String} color A hex string.\n\t     */\n\t    value: function rect() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t      var w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n\t      var h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n\t      var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"#000000\";\n\t\n\t      this.ctx.fillStyle = color;\n\t      this.ctx.fillRect(x, y, w, h);\n\t    }\n\t  }, {\n\t    key: \"drawLineXY\",\n\t\n\t\n\t    /**\n\t     * @memberOf Shapes\n\t     * @description Draw a line between these two points.\n\t     * @param  {Number} x0\n\t     * @param  {Number} y0\n\t     * @param  {Number} x1\n\t     * @param  {Number} y1\n\t     * @param  {string} style\n\t     */\n\t    value: function drawLineXY(x0, y0, x1, y1) {\n\t      var style = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"#000000\";\n\t\n\t      this.ctx.beginPath();\n\t      this.ctx.strokeStyle = style;\n\t      this.ctx.moveTo(x0, y0);\n\t      this.ctx.lineTo(x1, y1);\n\t      this.ctx.stroke();\n\t    }\n\t  }, {\n\t    key: \"drawLineVec\",\n\t\n\t\n\t    /**\n\t     * drawLineVec\n\t     * @param  {Vector} vec0: Vector\n\t     * @param  {Vector} vec1: Vector\n\t     */\n\t    value: function drawLineVec(vec0, vec1) {\n\t      this.drawLineXY(vec0.get(\"x\"), vec0.get(\"y\"), vec1.get(\"x\"), vec1.get(\"y\"));\n\t    }\n\t  }, {\n\t    key: \"drawLinePoints\",\n\t\n\t\n\t    /**\n\t     * drawLinePoints\n\t     * @param  {Object} firstPoint\n\t     * @param  {Array<Object>} points\n\t     */\n\t    value: function drawLinePoints(points) {\n\t      if (!points[0]) {\n\t        throw new Error(\"Please provide valid inputs\");\n\t      }\n\t\n\t      if (points.length < 1) {\n\t        throw new Error(\"Must be given a a number of points greater than 1\");\n\t      }\n\t\n\t      var firstPoint = points.shift();\n\t\n\t      this.ctx.beginPath();\n\t      this.ctx.moveTo(firstPoint.x, firstPoint.y);\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var point = _step.value;\n\t\n\t          this.ctx.lineTo(point.x, point.y);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.ctx.stroke();\n\t      this.ctx.closePath();\n\t    }\n\t  }, {\n\t    key: \"grid\",\n\t\n\t\n\t    /**\n\t     * @memberOf Shapes\n\t     * @param  {number} width\n\t     * @param  {number} height\n\t     * @param  {Number} gridSize\n\t     * @param  {String} color\n\t     */\n\t    value: function grid(width, height) {\n\t      var gridSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;\n\t      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"#ccc\";\n\t\n\t      this.ctx.beginPath();\n\t      this.ctx.strokeStyle = color;\n\t\n\t      for (var x = 0; x < width; x += gridSize) {\n\t        this.ctx.moveTo(x, 0);\n\t        this.ctx.lineTo(x, height);\n\t      }\n\t\n\t      for (var y = 0; y < height; y += gridSize) {\n\t        this.ctx.moveTo(0, y);\n\t        this.ctx.lineTo(width, y);\n\t      }\n\t\n\t      this.ctx.stroke();\n\t    }\n\t  }, {\n\t    key: \"pCircle\",\n\t\n\t\n\t    /**\n\t     * pCircle\n\t     * @memberOf Shapes\n\t     * @param  {Particle} p\n\t     * @return {Particle}\n\t     */\n\t    value: function pCircle(particle) {\n\t      this.circle(particle.state.x, particle.state.y, particle.state.radius, particle.state.color);\n\t      return particle;\n\t    }\n\t  }, {\n\t    key: \"pRect\",\n\t\n\t\n\t    /**\n\t     * pRect\n\t     * @memberOf Shapes\n\t     * @param  {Particle} p\n\t     * @return {Particle}\n\t     */\n\t    value: function pRect(particle) {\n\t      this.rect(particle.state.x, particle.state.y, particle.state.width, particle.state.height, particle.state.color);\n\t      return particle;\n\t    }\n\t  }]);\n\t\n\t  return Shapes;\n\t}();\n\t\n\tmodule.exports = Shapes;\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * YAT stands for Yet Another Tween.\n\t * Why not have one more package that does the same thing as the 50 out there?\n\t * Well thats a good question that will not be answered in this comment block.\n\t * To be honest its for practice and learning purposes. And if anyone in their\n\t * right mind actaully benefits from this then so be it.\n\t */\n\t\n\tvar clone = __webpack_require__(6);\n\tvar event = __webpack_require__(120);\n\tvar utils = __webpack_require__(3);\n\t\n\tvar DEFAULTS = {\n\t  obj: { x: 0, y: 0 },\n\t  props: { x: 100, y: 100 },\n\t  easing: \"ease\",\n\t  duration: 1000\n\t};\n\t\n\tvar eventInstance = event.init();\n\t// Inherit methods from eventInstance\n\tvar YAT = Object.create(eventInstance);\n\t\n\tYAT.init = function initTween(opts) {\n\t  // Can and uses Event and Clock methods.\n\t\n\t  if (!opts.clock) {\n\t    throw new Error(\"Please provide a clock API.\");\n\t  }\n\t\n\t  this._clock = opts.clock.init({\n\t    fps: opts.fps || 60\n\t  });\n\t\n\t  this.parent = eventInstance;\n\t  this.tweens = [];\n\t\n\t  /**\n\t   * easingFns\n\t   * @description All easing functions are orignially written\n\t   * by robert penner, the tweening god.\n\t   * Here each method is passed a normalized value. Which is\n\t   * usually a number between 0 and 1. You can think of this number as\n\t   * a percentage of a range. With that normlized value / percentage we\n\t   * can map that percentage to another range. This is called interpolation.\n\t   * @see {@link http://robertpenner.com/easing/}\n\t   * @type {Object}\n\t   */\n\t  this.easingFns = {\n\t    // Here this ease function is linear as there is only one\n\t    // n value. Each ease function can be mapped to a polynomial.\n\t    ease: function ease(c, b, n) {\n\t      // polynomial: ax + b = c; where x is the normalized value\n\t      return c * n + b;\n\t    },\n\t    easeInQuad: function easeInQuad(c, b, n) {\n\t      // polynomial: 1x^2 + 0x + 0 = d;\n\t      return c * (n * n) + b;\n\t    },\n\t    easeOutQuad: function easeOutQuad(c, b, n) {\n\t      // polynomial: -1x^2 + 2x + 0 = d;\n\t      return c * (n * (2 - n)) + b;\n\t    },\n\t    easeInOutQuad: function easeInOutQuad(c, b, n) {\n\t      if ((n *= 2) < 1) {\n\t        return c / 2 * (n * n) + b; // Polynomial for half the range:\n\t        // 2x^2 + 0x + 0 = d;\n\t      }\n\t      return -c / 2 * (--n * (n - 2) - 1) + b; // Polynomial for the the upper\n\t      // half of the range: -2x^2 + 4x - 1\n\t    }\n\t  };\n\t\n\t  this._clock.on(\"tick\", this.updateTweens, this);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * updateTweens - Updates all the tween instances.\n\t */\n\tYAT.updateTweens = function updateTeens() {\n\t  this.tweens.forEach(function (tween) {\n\t    if (tween.ticker.needsUpdate) {\n\t      tween.update(tween.ticker);\n\t    }\n\t\n\t    if (!tween.ticker.needsUpdate && tween.ticker.STATE === \"DONE\") {\n\t      tween.update(tween.ticker);\n\t      tween.remove();\n\t    }\n\t\n\t    if (tween.ticker.stopped) {\n\t      console.log(\"Your tween is stopped.\");\n\t    }\n\t  });\n\t};\n\t\n\tYAT.create = function () {\n\t  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var YATInstance = Object.create(YAT);\n\t  var _opts = Object.assign(clone(DEFAULTS), opts);\n\t  var duration = _opts.duration,\n\t      obj = _opts.obj,\n\t      props = _opts.props,\n\t      easing = _opts.easing,\n\t      id = _opts.id;\n\t\n\t\n\t  if (!YATInstance.easingFns[easing]) {\n\t    throw new Error(\"The easing function \" + easing + \" does not exists\");\n\t  }\n\t\n\t  if (id) {\n\t    if (this.tweens.some(function (x) {\n\t      return x.id === id;\n\t    })) {\n\t      throw new Error(\"The tween with id: \" + id + \" already exists.\");\n\t    }\n\t\n\t    YATInstance.id = id;\n\t  } else {\n\t    YATInstance.id = this.tweens.length + 1;\n\t  }\n\t\n\t  YATInstance.state = clone(obj);\n\t  YATInstance.obj = obj;\n\t  YATInstance.props = props;\n\t  YATInstance.duration = duration;\n\t  YATInstance.easing = YATInstance.easingFns[easing];\n\t  YATInstance.ticker = this._clock.createSlave({\n\t    id: YATInstance.id,\n\t    duration: YATInstance.duration\n\t  });\n\t\n\t  this.tweens.push(YATInstance);\n\t  return YATInstance;\n\t};\n\t\n\tYAT.get = function (id) {\n\t  if (this.tweens.length === 1) {\n\t    return YAT[0];\n\t  }\n\t\n\t  for (var i = 0; i < this.tween.length; i++) {\n\t    if (this.tween[i].id === id) {\n\t      return this.tween[i];\n\t    }\n\t  }\n\t\n\t  return false;\n\t};\n\t\n\tYAT.rewind = function () {\n\t  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n\t\n\t  var tween = this.get(id);\n\t\n\t  if (!this.stopped) {\n\t    tween.stop();\n\t  }\n\t\n\t  // Figure out a way to cache the old props //\n\t  this.opts.obj = this.opts.props;\n\t  this.opts.props = this.opts.propsBeforeTween;\n\t\n\t  tween.start();\n\t};\n\t\n\tYAT.startAll = function startAll() {\n\t  if (!this.tweens.length) {\n\t    throw new Error(\"There are no tweens to start\");\n\t  }\n\t\n\t  this.tweens.forEach(function (t) {\n\t    t.ticker.start();\n\t  });\n\t\n\t  this._clock.start();\n\t};\n\t\n\t/**\n\t * stopAll - Stops all tweens\n\t */\n\tYAT.stopAll = function stopAll() {\n\t  if (this.tweens.length) {\n\t    throw new Error(\"There are no tweens to stop\");\n\t  }\n\t\n\t  this._clock.stop();\n\t};\n\t\n\t/**\n\t * delay - how long to delay the animation\n\t * @param  {number} duration\n\t * @return {YAT}\n\t */\n\tYAT.delay = function delay(duration) {\n\t  var _this = this;\n\t\n\t  this.ticker.stop();\n\t  this.obj = clone(this.state);\n\t  setTimeout(function () {\n\t    return _this.ticker.start();\n\t  }, duration);\n\t  return this;\n\t};\n\t\n\t/**\n\t * stop - stops the ticker\n\t * @return {YAT}\n\t */\n\tYAT.stop = function stop() {\n\t  this.ticker.stop();\n\t  return this;\n\t};\n\t\n\t/**\n\t * finish - finishes the tween animation\n\t * @return {YAT}\n\t */\n\tYAT.finish = function finish() {\n\t  this.stop();\n\t  this._clock.removeSlave(this.ticker.id);\n\t  this.state = this.props;\n\t  return this;\n\t};\n\t\n\tYAT.remove = function remove() {\n\t  var _this2 = this;\n\t\n\t  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n\t\n\t  this.tweens = this.tweens.filter(function (t) {\n\t    if (t.id === id) {\n\t      _this2._clock.removeSlave(t.ticker.id);\n\t      return false;\n\t    }\n\t\n\t    return true;\n\t  });\n\t};\n\t\n\tYAT.update = function update(ticker) {\n\t  if (!ticker.needsUpdate) {\n\t    this.state = Object.assign({}, this.props);\n\t    return this.state;\n\t  }\n\t\n\t  var delta = ticker.timeSinceStart,\n\t      duration = ticker.duration;\n\t\n\t  var norm = utils.normalize(delta, 0, duration.ms);\n\t\n\t  for (var key in this.obj) {\n\t    if (this.obj.hasOwnProperty(key)) {\n\t      if (this.obj[key] !== undefined && this.props[key] !== undefined) {\n\t        this.state[key] = this.easing(this.props[key] - this.obj[key], this.obj[key], norm);\n\t      }\n\t    }\n\t  }\n\t\n\t  return this.state;\n\t};\n\t\n\tmodule.exports = YAT;\n\t\n\t/* eslint-disable */\n\t\n\t/*\n\t *\n\t * TERMS OF USE - EASING EQUATIONS\n\t * \n\t * Open source under the BSD License. \n\t * \n\t * Copyright  2001 Robert Penner\n\t * All rights reserved.\n\t * \n\t * Redistribution and use in source and binary forms, with or without modification, \n\t * are permitted provided that the following conditions are met:\n\t * \n\t * Redistributions of source code must retain the above copyright notice, this list of \n\t * conditions and the following disclaimer.\n\t * Redistributions in binary form must reproduce the above copyright notice, this list \n\t * of conditions and the following disclaimer in the documentation and/or other materials \n\t * provided with the distribution.\n\t *\n\t * Neither the name of the author nor the names of contributors may be used to endorse\n\t * or promote products derived from this software without specific prior written permission\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n\t * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES O\n\t * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TH\n\t *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL\n\t *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUT\n\t *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n\t * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDIN\n\t *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\t * OF THE POSSIBILITY OF SUCH DAMAGE.\n\t *\n\t */\n\n/***/ },\n/* 120 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/**\n\t * Event\n\t * @type {Object}\n\t * @implements {utils}\n\t */\n\tvar Event = Object.create(null);\n\t\n\t/**\n\t * init\n\t * @memberOf Event\n\t * @description Initializes the event object.\n\t * @return {Event}\n\t */\n\tEvent.init = function initEvent() {\n\t  this.callbacks = {};\n\t  return this;\n\t};\n\t\n\t/**\n\t * emit\n\t * @description Executes the handeler that assocaited with the emitted event.\n\t * @param {Array} args\n\t * @return {Event}\n\t */\n\tEvent.emit = function emit() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  var event = args[0],\n\t      rest = args.slice(1);\n\t\n\t\n\t  if (!event) {\n\t    throw new TypeError(\"Event: Please provide truthy arguments\");\n\t  }\n\t\n\t  this.callbacks[event] = this.callbacks[event] || [];\n\t\n\t  if (this.callbacks[event].length) {\n\t    this.callbacks[event].forEach(function (callback) {\n\t      callback.apply(undefined, _toConsumableArray(rest));\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * on\n\t * @description Attach a handler to an event.\n\t * @param  {String}   event\n\t * @param  {Function} fn\n\t * @param  {Object}   context\n\t * @return {Event}\n\t */\n\tEvent.on = function on(event, fn, context) {\n\t  var _this = this;\n\t\n\t  if (!event || !fn) {\n\t    throw new TypeError(\"Event: Please provide truthy arguments\");\n\t  }\n\t\n\t  if (context) {\n\t    fn = fn.bind(context);\n\t  }\n\t\n\t  var events = event.split(\" \");\n\t\n\t  this.callbacks = this.callbacks || {};\n\t\n\t  events.forEach(function (e) {\n\t    _this.callbacks[e] = _this.callbacks[e] || [];\n\t\n\t    if (!_this.callbacks[e].length) {\n\t      _this.callbacks[e].push(fn);\n\t      return _this;\n\t    }\n\t\n\t    // Dont create duplicates of the same handeled function.\n\t    // If you want your function run twice wrap it in a function.\n\t    return _this.callbacks[e].every(function (cb, i, col) {\n\t      return cb !== fn;\n\t    }) ? _this.callbacks[e].push(fn) : console.warn(\"Event: That function \" + fn + \" has already been declared a\" + \"handler for this event.\");\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * off\n\t * @description Remove an event handeler.\n\t * @param  {String}   event\n\t * @param  {Function} fn\n\t * @return {Event}\n\t */\n\tEvent.off = function off() {\n\t  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t    args[_key2] = arguments[_key2];\n\t  }\n\t\n\t  var event = args[0],\n\t      fn = args[1];\n\t\n\t\n\t  if (!event) {\n\t    this.callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  var callbacks = this.callbacks[event];\n\t\n\t  if (!callbacks) {\n\t    console.warn(\"Event: No event named \" + event + \" has been registered\");\n\t    return this;\n\t  }\n\t\n\t  if (!fn) {\n\t    delete this.callbacks[event];\n\t    return this;\n\t  }\n\t\n\t  this.callbacks[event] = callbacks.filter(function (cb) {\n\t    return cb !== fn;\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * listeners - Return all callbacks attached to a certain event\n\t * @param  {any<Array>} args\n\t * @return {function[]}\n\t */\n\tEvent.listeners = function listeners() {\n\t  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t    args[_key3] = arguments[_key3];\n\t  }\n\t\n\t  var event = args[0];\n\t\n\t\n\t  if (!event) {\n\t    return Object.keys(this.callbacks);\n\t  }\n\t\n\t  if (!this.callbacks[event]) {\n\t    console.warn(\"Event: No event named \" + event + \" has been registered\");\n\t  }\n\t\n\t  return this.callbacks[event];\n\t};\n\t\n\tEvent.once = function once() {\n\t  var self = this;\n\t\n\t  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n\t    args[_key4] = arguments[_key4];\n\t  }\n\t\n\t  var event = args[0],\n\t      fn = args[1],\n\t      context = args[2];\n\t\n\t\n\t  var wrap = function wrap() {\n\t    fn.bind(context)();\n\t    self.off(event, wrap);\n\t  };\n\t\n\t  this.on(event, wrap, context);\n\t};\n\t\n\t// Aliases //\n\tEvent.removeListener = Event.removeAllListeners = Event.off;\n\tEvent.fire = Event.emit;\n\tEvent.addListener = Event.on;\n\tEvent.get = Event.listeners;\n\t\n\tmodule.exports = Event;\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar ticker = __webpack_require__(122);\n\tvar event = __webpack_require__(120).init();\n\tvar Clock = Object.create(event);\n\tvar MAX_FPS = 60;\n\tvar noop = function noop() {};\n\t\n\t/**\n\t * init - Initalizes the clock with correct properties.\n\t * @param  {Object} opts\n\t * @param  {Number} opts.fps The fps you want the clock to tick at.\n\t * @return {Clock}\n\t */\n\tClock.init = function initClock() {\n\t  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  opts = Object.assign({\n\t    fps: MAX_FPS\n\t  }, opts);\n\t\n\t  this.slaves = [];\n\t  this.parent = event;\n\t\n\t  // Zero based frame count.\n\t  this.index = -1;\n\t\n\t  // Save a reference to the animation frame so we can cancel it\n\t  this.rAF = 0;\n\t\n\t  // Time properties\n\t  this.startTime;\n\t  this.lastTime;\n\t  this.stopTime;\n\t  this.timeSinceStart = 0;\n\t\n\t  // The maximum FPS the browser can deliver is 60.\n\t  this.fps = opts.fps > MAX_FPS ? MAX_FPS : opts.fps || MAX_FPS;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * start - Starts the clock with starting time properties.\n\t * @param  {Number} fps The fps you want the clock to tick at.\n\t * @return {Clock}\n\t */\n\tClock.start = function start() {\n\t  if (this.fps > 60) {\n\t    throw new Error(\"The given fps is too high\");\n\t  }\n\t\n\t  if (+this.fps === NaN) {\n\t    throw new Error(\"The given fps is not valid\");\n\t  }\n\t\n\t  this.fps = 1000 / this.fps;\n\t  this.startTime = performance.now();\n\t  this.lastTime = this.startTime;\n\t\n\t  // Start ticking\n\t  this.loop(this.startTime);\n\t  return this;\n\t};\n\t\n\t/**\n\t * tick\n\t * @param  {Number} newTime A value in ms that is equal to the current time.\n\t * @return {Clock}\n\t */\n\tClock.loop = function loop(newTime) {\n\t  this.rAF = requestAnimationFrame(loop.bind(this));\n\t\n\t  var delta = newTime - this.lastTime;\n\t  this.timeSinceStart = newTime - this.startTime;\n\t\n\t  if (delta > this.fps) {\n\t    this.index++;\n\t\n\t    this.whipSlaves({\n\t      newTime: newTime,\n\t      delta: delta,\n\t      index: this.index,\n\t      lastTime: this.lastTime,\n\t      clockStart: this.startTime,\n\t      timeSinceStart: this.timeSinceStart\n\t    });\n\t\n\t    this.lastTime = newTime - delta % this.fps;\n\t  }\n\t\n\t  this.emit(\"render\");\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * stop - Stop the clock and call the last tick if needed.\n\t * @return {Clock}\n\t */\n\tClock.stop = function stopClock() {\n\t  cancelAnimationFrame(this.rAF);\n\t\n\t  // Record when we stopped.\n\t  this.stopTime = performance.now();\n\t  this.timeSinceStart += this.stopTime - this.startTime;\n\t  this.clearSlaves();\n\t\n\t  this.emit(\"stopped\");\n\t  return this;\n\t};\n\t\n\t/**\n\t * whipSlaves - Run all slaves in sequence and pass in\n\t * the given state of the clock.\n\t * @param  {Object} state\n\t * @return {Clock}\n\t */\n\tClock.whipSlaves = function whipSlaves(state) {\n\t  if (!this.slaves.length) return;\n\t\n\t  this.slaves.forEach(function (slave, index) {\n\t    slave.nudge(state);\n\t  });\n\t\n\t  this.emit(\"tick\");\n\t  return this;\n\t};\n\t\n\tClock.createSlave = function createSlave(opts) {\n\t  if (!opts) {\n\t    throw new Error(\"Please provide a options object\");\n\t  }\n\t\n\t  var id = opts.id,\n\t      duration = opts.duration;\n\t\n\t  var timeStamp = performance.now();\n\t\n\t  var slave = Object.create(ticker).init({ timeStamp: timeStamp, id: id, duration: duration });\n\t\n\t  if (id) {\n\t    this.slaves.push(slave);\n\t    return slave;\n\t  }\n\t\n\t  slave.id = this.slaves.push(slave);\n\t  return slave;\n\t};\n\t\n\tClock.removeSlave = function removeSlave(id) {\n\t  this.slaves = this.slaves.filter(function (slave) {\n\t    if (slave.id !== id) {\n\t      return true;\n\t    }\n\t    slave.removeAllListeners();\n\t    return false;\n\t  });\n\t};\n\t\n\tClock.clearSlaves = function clearSlaves() {\n\t  if (this.slaves.length) this.slaves = [];\n\t};\n\t\n\tClock.reset = function () {\n\t  this.stop();\n\t  this.clearSlaves();\n\t  this.removeAllListeners();\n\t  this.rAF = 0;\n\t};\n\t\n\tClock.removeAllSlaves = Clock.clearSlaves;\n\t\n\tmodule.exports = Clock;\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar event = __webpack_require__(120);\n\tvar MAX_FPS = 1000 / 60;\n\tvar Ticker = Object.create(event);\n\tvar STATE = {\n\t  STOPPED: \"STOPPED\",\n\t  RUNNING: \"RUNNING\",\n\t  DONE: \"DONE\"\n\t};\n\t\n\tTicker.init = function init(_ref) {\n\t  var _ref$timeStamp = _ref.timeStamp,\n\t      timeStamp = _ref$timeStamp === undefined ? performance.now() : _ref$timeStamp,\n\t      id = _ref.id,\n\t      _ref$duration = _ref.duration,\n\t      duration = _ref$duration === undefined ? 1000 : _ref$duration,\n\t      _ref$interval = _ref.interval,\n\t      interval = _ref$interval === undefined ? MAX_FPS : _ref$interval;\n\t\n\t  this.id = id;\n\t  this.parent = event;\n\t  this.parent.name = \"event\";\n\t\n\t  // Probably cant support this??\n\t  // You have to have your own clock.\n\t  this.interval = interval;\n\t  this.duration = this.tickFor(duration, \"ms\");\n\t\n\t  this.STATE;\n\t  this.delta;\n\t  this.stopTime;\n\t  this.startTime = 0;\n\t  this.timeSinceStart = 0;\n\t  this.timeSinceStart2 = 0;\n\t\n\t  // Fire the first time you get called.\n\t  this.needsUpdate = true;\n\t\n\t  return this;\n\t};\n\t\n\tTicker.tickFor = function tickFor(duration, string) {\n\t  switch (string) {\n\t    case \"frames\":case \"f\":\n\t      return {\n\t        type: \"frames\",\n\t        value: duration,\n\t        ms: duration * MAX_FPS\n\t      };\n\t    case \"seconds\":case \"s\":\n\t      return {\n\t        type: \"seconds\",\n\t        value: duration,\n\t        ms: duration * 1000\n\t      };\n\t    case \"milliseconds\":case \"ms\":default:\n\t      return {\n\t        type: \"milliseconds\",\n\t        value: duration,\n\t        ms: duration\n\t      };\n\t  };\n\t};\n\t\n\tTicker.start = function start() {\n\t  if (this.STATE === STATE.RUNNING) return false;\n\t  this.STATE = STATE.RUNNING;\n\t  this.startTime = performance.now();\n\t};\n\t\n\tTicker.stop = function stop() {\n\t  if (this.STATE === STATE.STOPPED) return false;\n\t  this.STATE = STATE.STOPPED;\n\t\n\t  // Know what time it stopped.\n\t  // so that if it starts again it\n\t  // it can recalculate how far it needs to go.\n\t  var newDuration = this.duration.ms - this.timeSinceStart || 0;\n\t\n\t  this.duration = this.tickFor(newDuration, \"milliseconds\");\n\t  this.timeSinceStart = 0;\n\t\n\t  this.stopTime = performance.now();\n\t};\n\t\n\tTicker.nudge = function nudge(state) {\n\t  if (!state) {\n\t    throw new Error(\"Please provide a state object\");\n\t  }\n\t\n\t  if (this.STATE === STATE.STOPPED || this.STATE !== STATE.RUNNING) {\n\t    this.needsUpdate = false;\n\t    return null;\n\t  }\n\t\n\t  this.STATE = STATE.RUNNING;\n\t  this.timeSinceStart += state.delta;\n\t\n\t  if (this.timeSinceStart < this.duration.ms) {\n\t    this.needsUpdate = true;\n\t  } else {\n\t    this.STATE = STATE.DONE;\n\t    this.needsUpdate = false;\n\t  }\n\t};\n\t\n\tmodule.exports = Ticker;\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyZTlhOTEyYjJlYjMzZGJlZWRmZCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZlY3RvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3BhcnRpY2xlLmpzIiwid2VicGFjazovLy8uL34vZXh0ZW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2Nsb25lRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYWRkTWFwRW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FkZFNldEVudHJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zaGFwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi90d2Vlbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2V2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvY2xvY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi90aWNrZXIuanMiXSwibmFtZXMiOlsiVmVjdG9yIiwicmVxdWlyZSIsIlBhcnRpY2xlIiwiVXRpbHMiLCJTaGFwZXMiLCJZQVQiLCJDbG9jayIsIlRpY2tlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1dGlscyIsIklOSVRJQUxfU1RBVEUiLCJ4IiwieSIsInN0YXRlIiwidmVjIiwicHJvcCIsInZhbCIsImhhc093blByb3BlcnR5IiwicmFkIiwibGVuZ3RoIiwiZ2V0TGVuZ3RoIiwic2V0IiwiTWF0aCIsImNvcyIsInNpbiIsImdldEFuZ2xlIiwiZ2V0IiwiaHlwb3QiLCJhdGFuMiIsIm1pbiIsIm1heCIsImxlcnAiLCJyYW5kb20iLCJjcmVhdGUiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwicmFuZG9tQmV0d2VlbiIsInYyIiwiYW5nbGUiLCJ2MSIsImRWZWMiLCJzdWJ0cmFjdCIsInZlYzAiLCJ2ZWMxIiwieDAiLCJ5MCIsIngxIiwieTEiLCJyYW5nZUludGVyc2VjdCIsIm5vcm1hbGl6ZSIsIm1hcCIsInZhbHVlIiwic3JjTWluIiwic3JjTWF4IiwiZGVzdE1pbiIsImRlc3RNYXgiLCJwZXJjZW50IiwiY2xhbXAiLCJmbG9vciIsImRpc3RhbmNlWFkiLCJkeCIsImR5IiwiaW5SYW5nZSIsIm1pbjAiLCJtYXgwIiwibWluMSIsIm1heDEiLCJjb2xsaXNpb25SZWN0IiwicjAiLCJyMSIsInIweCIsInIweSIsInIxeCIsInIxeSIsInIwdyIsIndpZHRoIiwicjBoIiwiaGVpZ2h0IiwicjF3IiwicjFoIiwiY29sbGlzaW9uQ2lyY2xlIiwiYzEiLCJjMiIsInJhZGkiLCJyYWRpdXMiLCJkaXN0YW5jZSIsImNvbGxpc2lvbkNpcmNsZVBvaW50IiwiY2lyY2xlIiwiZGlzdCIsImNvbGxpc2lvbkNpcmNsZVZlYyIsImNvbGxpc2lvblJlY3RQb2ludCIsInJlY3QiLCJyZWN0WCIsInJlY3RZIiwiY29sbGlzaW9uUmVjdFZlYyIsInRocm90dGxlIiwiZnVuYyIsIndhaXQiLCJvcHRpb25zIiwiY29udGV4dCIsImFyZ3MiLCJyZXN1bHQiLCJ0aW1lb3V0IiwicHJldmlvdXMiLCJsYXRlciIsImxlYWRpbmciLCJEYXRlIiwibm93IiwiYXBwbHkiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJ0cmFpbGluZyIsInNldFRpbWVvdXQiLCJzZXRMZW5ndGgiLCJFcnJvciIsInNldEFuZ2xlIiwiZGVnVG9SYWQiLCJkZWciLCJQSSIsInJhZFRvRGVnIiwicm91bmRUb1BsYWNlcyIsInBsYWNlcyIsIm11bHQiLCJwb3ciLCJyb3VuZCIsInJvdW5kVG9NdWx0aXBsZSIsIm5lYXJlc3QiLCJTdHJpbmciLCJxdWFkcmF0aWNCZXppZXIiLCJ2MCIsInQiLCJjdWJpY0JlemllciIsInYzIiwicXVhZHJhdGljQmV6aWVyUG9pbnQiLCJwMCIsInAxIiwicDIiLCJjdWJpY0JlemllclBvaW50IiwicDMiLCJtdWx0aUN1cnZlIiwicG9pbnRzIiwiY3R4IiwibWlkWCIsIm1pZFkiLCJtb3ZlVG8iLCJpIiwicXVhZHJhdGljQ3VydmVUbyIsImVhc2UiLCJhIiwiYiIsInRocmVzaG9sZCIsImFicyIsImVhc2VUbyIsIm9yaWdpbiIsInRhcmdldCIsImlzT2JqZWN0IiwiZGF0YSIsInRvU3RyaW5nIiwiY2FsbCIsInVuaXF1ZSIsImFycmF5IiwicmVkdWNlIiwiaW5kZXhPZiIsInB1c2giLCJwZXJzcGVjdGl2ZSIsImZvY2FsTGVuZ3RoIiwiZXh0ZW5kIiwiY2xvbmUiLCJ2eCIsInZ5IiwiZ3Jhdml0eSIsIm1hZ25pdHVkZSIsIm1hc3MiLCJkaXJlY3Rpb24iLCJmcmljdGlvbiIsInNwcmluZ3MiLCJtYXNzZXMiLCJjb2xvciIsImF4IiwiYXkiLCJmcmljIiwiZ3JhdiIsImhhbmRsZVNwcmluZ3MiLCJoYW5kbGVNYXNzZXMiLCJhY2NlbGVyYXRlIiwidXBkYXRlUG9zIiwic3BlZWQiLCJnZXRIZWFkaW5nIiwiZ2V0U3BlZWQiLCJwIiwicmVtb3ZlTWFzcyIsInNwbGljZSIsInBhcnRpY2xlIiwiZGlzdFNxcmQiLCJzcXJ0IiwiZm9yY2UiLCJ1bmRlZmluZWQiLCJzcHJpbmciLCJyZW1vdmVTcHJpbmciLCJwb2ludCIsInNwcmluZ3kiLCJvZmZzZXQiLCJzcHJpbmdGb3JjZSIsInN4Iiwic3kiLCJzcHJpbmdUb1BvaW50IiwiZ3Jhdml0YXRlVG8iLCJzZXRTcGVlZCIsInNldEhlYWRpbmciLCJudW1iZXIiLCJvcHRzIiwicGFydGljbGVzIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJyIiwiZmlsbFN0eWxlIiwiYmVnaW5QYXRoIiwiYXJjIiwiZmlsbCIsInciLCJoIiwiZmlsbFJlY3QiLCJzdHlsZSIsInN0cm9rZVN0eWxlIiwibGluZVRvIiwic3Ryb2tlIiwiZHJhd0xpbmVYWSIsImZpcnN0UG9pbnQiLCJzaGlmdCIsImNsb3NlUGF0aCIsImdyaWRTaXplIiwiZXZlbnQiLCJERUZBVUxUUyIsIm9iaiIsInByb3BzIiwiZWFzaW5nIiwiZHVyYXRpb24iLCJldmVudEluc3RhbmNlIiwiaW5pdCIsIk9iamVjdCIsImluaXRUd2VlbiIsImNsb2NrIiwiX2Nsb2NrIiwiZnBzIiwicGFyZW50IiwidHdlZW5zIiwiZWFzaW5nRm5zIiwiYyIsIm4iLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwib24iLCJ1cGRhdGVUd2VlbnMiLCJ1cGRhdGVUZWVucyIsImZvckVhY2giLCJ0d2VlbiIsInRpY2tlciIsIm5lZWRzVXBkYXRlIiwidXBkYXRlIiwiU1RBVEUiLCJyZW1vdmUiLCJzdG9wcGVkIiwiY29uc29sZSIsImxvZyIsIllBVEluc3RhbmNlIiwiX29wdHMiLCJhc3NpZ24iLCJpZCIsInNvbWUiLCJjcmVhdGVTbGF2ZSIsInJld2luZCIsInN0b3AiLCJwcm9wc0JlZm9yZVR3ZWVuIiwic3RhcnQiLCJzdGFydEFsbCIsInN0b3BBbGwiLCJkZWxheSIsImZpbmlzaCIsInJlbW92ZVNsYXZlIiwiZmlsdGVyIiwiZGVsdGEiLCJ0aW1lU2luY2VTdGFydCIsIm5vcm0iLCJtcyIsImtleSIsIkV2ZW50IiwiaW5pdEV2ZW50IiwiY2FsbGJhY2tzIiwiZW1pdCIsInJlc3QiLCJUeXBlRXJyb3IiLCJjYWxsYmFjayIsImZuIiwiYmluZCIsImV2ZW50cyIsInNwbGl0IiwiZSIsImV2ZXJ5IiwiY2IiLCJjb2wiLCJ3YXJuIiwib2ZmIiwibGlzdGVuZXJzIiwia2V5cyIsIm9uY2UiLCJzZWxmIiwid3JhcCIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZmlyZSIsImFkZExpc3RlbmVyIiwiTUFYX0ZQUyIsIm5vb3AiLCJpbml0Q2xvY2siLCJzbGF2ZXMiLCJpbmRleCIsInJBRiIsInN0YXJ0VGltZSIsImxhc3RUaW1lIiwic3RvcFRpbWUiLCJOYU4iLCJwZXJmb3JtYW5jZSIsImxvb3AiLCJuZXdUaW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2hpcFNsYXZlcyIsImNsb2NrU3RhcnQiLCJzdG9wQ2xvY2siLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyU2xhdmVzIiwic2xhdmUiLCJudWRnZSIsInRpbWVTdGFtcCIsInJlc2V0IiwicmVtb3ZlQWxsU2xhdmVzIiwiU1RPUFBFRCIsIlJVTk5JTkciLCJET05FIiwiaW50ZXJ2YWwiLCJuYW1lIiwidGlja0ZvciIsInRpbWVTaW5jZVN0YXJ0MiIsInN0cmluZyIsInR5cGUiLCJuZXdEdXJhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7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QTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FB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IjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInBhcnRpY2xlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInBhcnRpY2xlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDJlOWE5MTJiMmViMzNkYmVlZGZkIiwiY29uc3QgVmVjdG9yID0gcmVxdWlyZShcIi4vbGliL3ZlY3RvcnNcIik7XG5jb25zdCBQYXJ0aWNsZSA9IHJlcXVpcmUoXCIuL2xpYi9wYXJ0aWNsZVwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vbGliL3V0aWxzXCIpO1xuY29uc3QgU2hhcGVzID0gcmVxdWlyZShcIi4vbGliL3NoYXBlc1wiKTtcbmNvbnN0IFlBVCA9IHJlcXVpcmUoXCIuL2xpYi90d2VlblwiKTtcbmNvbnN0IENsb2NrID0gcmVxdWlyZShcIi4vbGliL2Nsb2NrLmpzXCIpO1xuY29uc3QgVGlja2VyID0gcmVxdWlyZShcIi4vbGliL3RpY2tlci5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFZlY3RvcixcbiAgUGFydGljbGUsXG4gIFV0aWxzLFxuICBTaGFwZXMsXG4gIFlBVCxcbiAgVGlja2VyLFxuICBDbG9jayxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyIsIi8qIGVzbGludCBtYXgtbGVuOiAwICovXG5cbi8vICAgICAgXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5cbmNvbnN0IElOSVRJQUxfU1RBVEUgPSB7XG4gIHg6IDAsXG4gIHk6IDEsXG59O1xuXG4vKipcbiAqIFZlY3RvciBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgZG9pbmcgdmVjdG9yIG9wZXJhdGlvbnMgYW5kIHN0b3JpbmdcbiAqIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSB2ZWN0b3IuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgVmVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgb2JqZWN0LlxuICovXG5jbGFzcyBWZWN0b3Ige1xuICAgICAgICAgIFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgXG4gICAgXG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3RhdGUgSW5pdGlhbCBzdGF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RhdGUgICAgICAgICA9IElOSVRJQUxfU1RBVEUpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIC0gRWFzeSB3YXkgdG8gaW5zdGFudGlhdGUgYSB2ZWN0b3IuXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtICB7SW50fSB4XG4gICAqIEBwYXJhbSAge0ludH0geVxuICAgKiBAcmV0dXJuIHtWZWN0b3J9ICAgQSBvYmplY3QgaW5oZXJpdGluZyBmcm9tIFZlY3Rvci5cbiAgICovXG4gIGNyZWF0ZSh4ICAgICAgICAgPSAwLCB5ICAgICAgICAgPSAwKSAgICAgICAgIHtcbiAgICBjb25zdCB2ZWMgPSBuZXcgVmVjdG9yKHt4LCB5fSk7XG4gICAgcmV0dXJuIHZlYztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IC0gQSBzZXR0ZXIgZm9yIHRoZSB2ZWN0b3IgY2xhc3MuXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtICB7Kn0gcHJvcFxuICAgKiBAcGFyYW0gIHsqfSB2YWxcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gSXMgdGhlIHByb3AgeW91ciBwYXNzaW5nIGluIGV4c2lzdC5cbiAgICovXG4gIHNldChwcm9wICAgICAgICAsIHZhbCAgICAgKSAgICAgICAgICB7XG4gICAgLy8gVE9ETzogQWRkIGNoZWNrIHZhbCBpcyBudW1iZXJcbiAgICAvLyAxLiBDcmVhdGUgdXRpbHMuaXNOdW1iZXIgZnVuY3Rpb24uXG5cbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdGhpcy5zdGF0ZVtwcm9wXSA9IHZhbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogZ2V0IC0gQSBnZXR0ZXIgZm9yIHRoZSB2ZWN0b3IgY2xhc3MuXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwcm9wICBUaGUgcHJvcCB0byBzZXQgb24gc3RhdGUuXG4gICAqIEByZXR1cm4ge1ZhbHVlfSAgICAgICAgVGhlIHZhbHVlIGFzc29zaWF0ZWQgd2l0aCB0aGUgcHJvcC5cbiAgICovXG4gIGdldChwcm9wICAgICAgICApICAgICAge1xuICAgIHJldHVybiB0aGlzLnN0YXRlW3Byb3BdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXRBbmdsZSAtIFBsb3QgdGhlIGNvcnJkaW5hdGVzIGJhc2VkIG9uIHJhZGlhbnMgZ2l2ZW4uXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtIHtSYWRpYW5zfSByYWQgQSBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICovXG4gIHNldEFuZ2xlKHJhZCAgICAgICAgKSAgICAgICAgIHtcbiAgICAvLyBUT0RPOiBBZGQgY2hlY2sgcmFkIGlzIG51bWJlclxuICAgIC8vIDEuIENyZWF0ZSB1dGlscy5pc051bWJlciBmdW5jdGlvbi5cblxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cbiAgICB0aGlzLnNldChcInhcIiwgTWF0aC5jb3MocmFkKSAqIGxlbmd0aCk7XG4gICAgdGhpcy5zZXQoXCJ5XCIsIE1hdGguc2luKHJhZCkgKiBsZW5ndGgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIHNldExlbmd0aCAtIFRha2VzIGEgbGVuZ3RoIGFuZCBzZXRzIGNvb3JkaW5hdGUuXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBsZW5ndGhcbiAgICogQHJldHVybiB7VmVjdG9yfVxuICAgKi9cbiAgc2V0TGVuZ3RoKGxlbmd0aCAgICAgICAgKSAgICAgICAgIHtcbiAgICAvLyBUT0RPOiBBZGQgY2hlY2sgcmFkIGlzIG51bWJlclxuICAgIC8vIDEuIENyZWF0ZSB1dGlscy5pc051bWJlciBmdW5jdGlvbi5cblxuICAgIGNvbnN0IHJhZCA9IHRoaXMuZ2V0QW5nbGUoKTtcblxuICAgIHRoaXMuc2V0KFwieFwiLCBNYXRoLmNvcyhyYWQpICogbGVuZ3RoKTtcbiAgICB0aGlzLnNldChcInlcIiwgTWF0aC5zaW4ocmFkKSAqIGxlbmd0aCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogZ2V0TGVuZ3RoIC0gR2V0cyBsZW5ndGggb2YgdGhlIGNvb3JkaW5hdGVzIGZyb20gY2VudGVyIHBsYW5lLlxuICAgKiBAbWVtYmVyT2YgVmVjdG9yXG4gICAqIEByZXR1cm4ge0ludGVnZXJ9IENvb3JpZGluYXRlcy5cbiAgICovXG4gIGdldExlbmd0aCgpICAgICAgICAge1xuICAgIGNvbnN0IHggPSAodGhpcy5nZXQoXCJ4XCIpICAgICAgICApO1xuICAgIGNvbnN0IHkgPSAodGhpcy5nZXQoXCJ5XCIpICAgICAgICApO1xuICAgIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBnZXRBbmdsZSAtIEdldCB0aGUgYW5nbGUgb2YgY29vcmRpbmF0ZXMgZnJvbSBjZW50ZXIgcGxhbmUuXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHJldHVybiB7SW50ZWdlcn0gQ29vcmlkaW5hdGVzLlxuICAgKi9cbiAgZ2V0QW5nbGUoKSAgICAgICAgIHtcbiAgICBjb25zdCB4ID0gKHRoaXMuZ2V0KFwieFwiKSAgICAgICAgKTtcbiAgICBjb25zdCB5ID0gKHRoaXMuZ2V0KFwieVwiKSAgICAgICAgKTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KTtcbiAgfTtcblxuICAvKipcbiAgICogcmFuZG9tIGdlbmVyYXRlIGEgdmVjdG9yIHdpdGggcmFuZG9tIHN0YXRlcy5cbiAgICogQG1lbWJlck9mIFZlY3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0gbWluIC0gQSBtaW4gcmFuZ2Ugb24gdGhlIHJhbmRvbSB2ZWN0b3Igc3RhdGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggLSBBIG1heCByYW5nZSBvbiB0aGUgcmFuZG9tIHZlY3RvciBzdGF0ZS5cbiAgICogQHJldHVybiB7VmVjdG9yfVxuICAgKi9cbiAgcmFuZG9tKG1pbiAgICAgICAgPTEsIG1heCAgICAgICAgPTEwKSAgICAgICAgIHtcbiAgICBjb25zdCB4ID0gdXRpbHMubGVycChNYXRoLnJhbmRvbSgpLCBtaW4sIG1heCk7XG4gICAgY29uc3QgeSA9IHV0aWxzLmxlcnAoTWF0aC5yYW5kb20oKSwgbWluLCBtYXgpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh4LCB5KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlck9mIFZlY3RvclxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgdmVjdG9yIHRoYXQgaGFzIGEgeCBiZXR3ZWVuIHRoZSBnaXZlbiByYW5nZS5cbiAgICogICAgICAgICAgICAgIGFuZCB5IGdpdmVuIGEgcmFuZ2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geE1pbiBNaW5tdW0geCB2YWx1ZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhNYXggTWF4aW11bSB4IHZhbHVlXG4gICAqIEBwYXJhbSAge051bWJlcn0geU1pbiBNaW5tdW0geSB2YWx1ZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlNYXggTWF4aW11bSB5IHZhbHVlXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgICovXG4gIHJhbmRvbUJldHdlZW4oeE1pbiAgICAgICAgPTAsIHhNYXggICAgICAgID0xMCwgeU1pbiAgICAgICAgPTAsIHlNYXggICAgICAgID0xMCkgICAgICAgICB7XG4gICAgeE1heCA9IE1hdGgubWF4KHhNaW4sIHhNYXgpO1xuICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCB4TWF4KTtcbiAgICB5TWF4ID0gTWF0aC5tYXgoeU1pbiwgeU1heCk7XG4gICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHlNYXgpO1xuXG4gICAgY29uc3QgeSA9ICh1dGlscy5yYW5kb21CZXR3ZWVuKHlNaW4sIHlNYXgpICAgICAgICApO1xuICAgIGNvbnN0IHggPSAodXRpbHMucmFuZG9tQmV0d2Vlbih4TWluLCB4TWF4KSAgICAgICAgKTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh4LCB5KTtcbiAgfTtcblxuICAvKipcbiAgICogYWRkIC0gU2hvdWxkIGFkZCB2ZWN0b3JzIHRvZ2V0aGVyIGdpdmVuIGEgdmVjdG9yXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtIHtWZWN0b3J9IHYyIEEgZ2l2ZW4gdmVjdG9yIHRvIGFkZC5cbiAgICogQHJldHVybiB7VmVjdG9yfSBBIHZlY3RvciB3aXRoIGNvb3JpZG5hdGVzLCBvciBtdWx0aXBsZSB2ZWN0b3JzLlxuICAgKi9cbiAgYWRkKHYyICAgICAgICApICAgICAgICAge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZShcbiAgICAgIHRoaXMuZ2V0KFwieFwiKSArIHYyLmdldChcInhcIiksXG4gICAgICB0aGlzLmdldChcInlcIikgKyB2Mi5nZXQoXCJ5XCIpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogc3VidHJhY3QgLSBzaG91bGQgc3VidHJhY3QgdGhlIGdpdmVuIHZlY3RvciB3aXRoIGl0cyBvd24gdmVjdG9yLlxuICAgKiBAbWVtYmVyT2YgVmVjdG9yXG4gICAqIEBwYXJhbSAge1ZlY3Rvcn0gdjIgQSB2ZWN0b3IgdGhhdCBjb250YWlucyBzdGF0ZS5cbiAgICogQHJldHVybiB7VmVjdG9yfSBBIHZlY3RvciB0aGF0IGNvbnRhaW5zIGEgcmVkdWNlZCBzdGF0ZS5cbiAgICogQGV4YW1wbGUge3g6IDIsIHk6IDJ9IC0ge3g6IDIsIHk6IDJ9ID0ge3g6IDAsIHk6IDB9XG4gICAqL1xuICBzdWJ0cmFjdCh2MiAgICAgICAgKSAgICAgICAgIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGUoXG4gICAgICB0aGlzLmdldChcInhcIikgLSB2Mi5nZXQoXCJ4XCIpLFxuICAgICAgdGhpcy5nZXQoXCJ5XCIpIC0gdjIuZ2V0KFwieVwiKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE11bGl0cGx5aW5nIHZlY3RvcnMgdG9nZXRoZXJcbiAgICogQG1lbWJlck9mIFZlY3RvclxuICAgKiBAZXhhbXBsZSB7eDogMiwgeTogMn0gKiB7eDogMiwgeTogMn0gPSB7eDogNCwgeTogNH1cbiAgICogQHBhcmFtICB7VmVjdG9yfSB2MiBBIHZlY3RvciB0aGF0IGNvbnRhaW5zIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtWZWN0b3J9ICAgIEEgdmVjdG9yIHRoYXQgY29udGFpbnMgYSByZWR1Y2VkIHN0YXRlLlxuICAgKi9cbiAgbXVsdGlwbHkodjIgICAgICAgICkgICAgICAgICB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKFxuICAgICAgdGhpcy5nZXQoXCJ4XCIpICogdjIuZ2V0KFwieFwiKSxcbiAgICAgIHRoaXMuZ2V0KFwieVwiKSAqIHYyLmdldChcInlcIilcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXZpZGUgdmVjdG9ycyB0b2dldGhlci5cbiAgICogQG1lbWJlck9mIFZlY3RvclxuICAgKiBAcGFyYW0gIHtWZWN0b3J9IHYyIEEgdmVjdG9yIHRoYXQgY29udGFpbnMgc3RhdGUuXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn0gICAgQSB2ZWN0b3IgdGhhdCBjb250YWlucyBhIHJlZHVjZWQgc3RhdGUuXG4gICAqL1xuICBkaXZpZGUodjIgICAgICAgICkgICAgICAgICB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKFxuICAgICAgdGhpcy5nZXQoXCJ4XCIpIC8gdjIuZ2V0KFwieFwiKSxcbiAgICAgIHRoaXMuZ2V0KFwieVwiKSAvIHYyLmdldChcInlcIilcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIHRvIGN1cnJlbnQgc3RhdGUgdGhlIHN0YXRlIG9mIHYyXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtIHtWZWN0b3J9IFt2Ml0gLSBBIHZlY3RvciB0aGF0IGNvbnRhaW5zIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFtzdGF0ZV0gLSBLZXkgdmFsdWUgcGFpciBvZiBjb29yZGluYXRlc1xuICAgKi9cbiAgYWRkVG8odjIgICAgICAgICkgICAgICAgICB7XG4gICAgdGhpcy5zdGF0ZS54ID0gdGhpcy5nZXQoXCJ4XCIpICsgdjIuZ2V0KFwieFwiKTtcbiAgICB0aGlzLnN0YXRlLnkgPSB0aGlzLmdldChcInlcIikgKyB2Mi5nZXQoXCJ5XCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgZnJvbSBjdXJyZW50IHN0YXRlIHRoZSBzdGF0ZSBvZiB2MlxuICAgKiBAbWVtYmVyT2YgVmVjdG9yXG4gICAqIEBwYXJhbSB7VmVjdG9yfSBbdjJdIC0gQSB2ZWN0b3IgdGhhdCBjb250YWlucyBzdGF0ZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBbc3RhdGVdIC0gS2V5IHZhbHVlIHBhaXIgb2YgY29vcmRpbmF0ZXNcbiAgICovXG4gIHN1YnRyYWN0RnJvbSh2MiAgICAgICAgKSAgICAgICAgIHtcbiAgICB0aGlzLnN0YXRlLnggPSB0aGlzLmdldChcInhcIikgLSB2Mi5nZXQoXCJ4XCIpO1xuICAgIHRoaXMuc3RhdGUueSA9IHRoaXMuZ2V0KFwieVwiKSAtIHYyLmdldChcInlcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIG11bGl0cGxpZXMgYnkgY3VycmVudCBzdGF0ZSB0aGUgc3RhdGUgb2YgdjJcbiAgICogQG1lbWJlck9mIFZlY3RvclxuICAgKiBAcGFyYW0ge1ZlY3Rvcn0gW3YyXSAtIEEgdmVjdG9yIHRoYXQgY29udGFpbnMgc3RhdGUuXG4gICAqIEByZXR1cm4ge09iamVjdH0gW3N0YXRlXSAtIEtleSB2YWx1ZSBwYWlyIG9mIGNvb3JkaW5hdGVzXG4gICAqL1xuICBtdWx0aXBseUJ5KHYyICAgICAgICApICAgICAgICAge1xuICAgIHRoaXMuc3RhdGUueCA9IHRoaXMuZ2V0KFwieFwiKSAqIHYyLmdldChcInhcIik7XG4gICAgdGhpcy5zdGF0ZS55ID0gdGhpcy5nZXQoXCJ5XCIpICogdjIuZ2V0KFwieVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIGJ5IGN1cnJlbnQgc3RhdGUgdGhlIHN0YXRlIG9mIHYyXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtIHtWZWN0b3J9IFt2Ml0gLSBBIHZlY3RvciB0aGF0IGNvbnRhaW5zIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFtzdGF0ZV0gLSBLZXkgdmFsdWUgcGFpciBvZiBjb29yZGluYXRlc1xuICAgKi9cbiAgZGl2aWRlQnkodjIgICAgICAgICkgICAgICAgICB7XG4gICAgdGhpcy5zdGF0ZS54ID0gdGhpcy5nZXQoXCJ4XCIpIC8gdjIuZ2V0KFwieFwiKTtcbiAgICB0aGlzLnN0YXRlLnkgPSB0aGlzLmdldChcInlcIikgLyB2Mi5nZXQoXCJ5XCIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBWZWN0b3JcbiAgICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZSBBIG51bWJlciBvZiByYWRpYW5zIHRvIHJvdGF0ZSBjbG9ja3dpc2UgYnkuXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn1cbiAgKi9cbiAgcm90YXRlQnkoYW5nbGUgICAgICAgICkgICAgICAgICB7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgIGNvbnN0IHggPSB0aGlzLnN0YXRlLnggKiBjb3MgLSB0aGlzLnN0YXRlLnkgKiBzaW47XG4gICAgY29uc3QgeSA9IHRoaXMuc3RhdGUueSAqIGNvcyArIHRoaXMuc3RhdGUueCAqIHNpbjtcblxuICAgIHRoaXMuc3RhdGUueCA9IHg7XG4gICAgdGhpcy5zdGF0ZS55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiB2MVxuICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdjEgVmVjdG9yXG4gICAqIEBwYXJhbSB7VmVjdG9yfSB2MiBWZWN0b3JcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGRpc3RhbmNlQmV0d2Vlbih2MSAgICAgICAgLCB2MiAgICAgICAgKSAgICAgICAgIHtcbiAgICBjb25zdCBkVmVjID0gdjEuc3VidHJhY3QodjIpO1xuICAgIHJldHVybiBNYXRoLmh5cG90KGRWZWMuZ2V0KFwieFwiKSwgZFZlYy5nZXQoXCJ5XCIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gR2l2ZW4gdHdvcyB2ZWN0b3JzIHNlZSBpZiB0aGV5IGludGVyc2VjdC5cbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBwYXJhbSAge1ZlY3Rvcn0gdmVjMFxuICAgKiBAcGFyYW0gIHtWZWN0b3J9IHZlYzFcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyB2ZWN0b3JJbnRlcnNlY3QodmVjMCAgICAgICAgLCB2ZWMxICAgICAgICApICAgICAgICAgIHtcbiAgICBjb25zdCB4MCA9IHZlYzAuZ2V0KFwieFwiKTtcbiAgICBjb25zdCB5MCA9IHZlYzAuZ2V0KFwieVwiKTtcbiAgICBjb25zdCB4MSA9IHZlYzEuZ2V0KFwieFwiKTtcbiAgICBjb25zdCB5MSA9IHZlYzEuZ2V0KFwieVwiKTtcbiAgICByZXR1cm4gdXRpbHMucmFuZ2VJbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL3ZlY3RvcnMuanMiLCIvLyAgICAgIFxuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGlzIGNvbXBvc2VkIG9mIHNtYWxsIGZ1bmN0aW9uIHRoYXRcbiAqIHNob3VsZCBiZSB1c2VkIHdoZW4gbmVlZGVkLiBNb3N0IGZ1bmN0aW9ucyBhcmUgcHVyZVxuICogYW5kIG9ubHkgcmV0dXJuIHZhbHVlcy4gRm9yIG1vcmUgaW5mbyByZWFkIHRoZSBkb2NzLlxuICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4vKipcbiAqIG5vcm1hbGl6ZSAtIFRha2VzIGEgbWF4IGFuZCBtaW4gdmFsdWUgYW5kIHJldHVybnNcbiAqIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCB0aGF0IHdoZW4gbXVsdGlwbGllZFxuICogYnkgb25lIGh1bmRyZWQgcmVwcmVzZW50cyBhIHByZWNlbnRhZ2Ugb2YgdGhlIHJhbmdlXG4gKiBiZXR3ZWVuIG1heCBhbmQgbWluLlxuICpcbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQHBhcmFtICB7SW50fSB2YWwgLSBUaGUgdmFsdWUgdGhhdCBsaWVzIGluIHRoZSByYW5nZS5cbiAqIEBwYXJhbSAge0ludH0gbWluIC0gVGhlIG1heGl1bSB2YWx1ZSBpbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0gIHtJbnR9IG1heCAtIFRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZS5cbiAqIEByZXR1cm4ge0ludH0gSW50IC0gVGhlIHZhbHVlIHJlcHJlc2VudGVkIGluIHRoYXQgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWwgICAgICAgICwgbWluICAgICAgICAsIG1heCAgICAgICAgKSAgICAgICAgIHtcbiAgcmV0dXJuICgodmFsIC0gbWluKSAvIChtYXggLSBtaW4pICAgICAgICApO1xufTtcblxuLyoqXG4gKiBsZXJwIC0gbGluZWFyIGludGVycG9sYXRpb24gdGFrZXMgYSByYW5nZSBhbmQgYSBnaXZlbiBub3JtYWxpemVkIHZhbHVlXG4gKiBhbmQgcmV0dXJucyBhIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGF0IG5vcm1hbGl6ZWQgdmFsdWUgaW4gdGhhdCByYW5nZS5cbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQHBhcmFtICB7SW50ZXJnZXJ9IHZhbFxuICogQHBhcmFtICB7SW50ZXJnZXJ9IG1pblxuICogQHBhcmFtICB7SW50ZXJnZXJ9IG1heFxuICogQHJldHVybiB7SW50ZXJnZXJ9XG4gKi9cbmZ1bmN0aW9uIGxlcnAodmFsICAgICAgICAsIG1pbiAgICAgICAgLCBtYXggICAgICAgICkgICAgICAgICB7XG4gIHJldHVybiAobWF4IC0gbWluKSAqIHZhbCArIG1pbjtcbn07XG5cbi8qKlxuICogbWFwIC0gR2l2ZW4gMiBzZXQgb2YgdmFsdWVzIG1hcCB0aGVtIHRvIGFub3RoZXIgc2V0LlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNyY01pblxuICogQHBhcmFtICB7bnVtYmVyfSBzcmNNYXhcbiAqIEBwYXJhbSAge251bWJlcn0gZGVzdE1pblxuICogQHBhcmFtICB7bnVtYmVyfSBkZXN0TWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG1hcCh2YWx1ZSAgICAgICAgLCBzcmNNaW4gICAgICAgICwgc3JjTWF4ICAgICAgICAsIGRlc3RNaW4gICAgICAgICwgZGVzdE1heCAgICAgICAgKSAgICAgICAgIHtcbiAgc3JjTWF4ID0gKE1hdGgubWF4KHNyY01heCwgc3JjTWluKSAgICAgICAgKTtcbiAgc3JjTWluID0gKE1hdGgubWluKHNyY01heCwgc3JjTWluKSAgICAgICAgKTtcbiAgZGVzdE1pbiA9IChNYXRoLm1pbihkZXN0TWluLCBkZXN0TWF4KSAgICAgICAgKTtcbiAgZGVzdE1heCA9IChNYXRoLm1heChkZXN0TWluLCBkZXN0TWF4KSAgICAgICAgKTtcbiAgcmV0dXJuIGxlcnAobm9ybWFsaXplKHZhbHVlLCBzcmNNaW4sIHNyY01heCksIGRlc3RNaW4sIGRlc3RNYXgpO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHByZWNlbnRhZ2UuXG4gKiAgICAgICAgICAgICAgeW91IGNhbiBwYXNzIGFyYml0cmFyeSBsYXJnZSBudW1iZXJzIGluIGJ1dCB0aGF0cyBub3RcbiAqICAgICAgICAgICAgICB0aGUgaW50ZW5kZWQgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7RmxvYXR9IHZhbCBcdEEgdmFsdWUuXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEByZXR1cm4ge1BlcmNlbnR9ICAgIEEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBlcmNlbnQodmFsICAgICAgICApICAgICAgICAge1xuICByZXR1cm4gKCh2YWwgKiAxMDApICAgICAgICApO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2l2ZW4gYSBudW1iZXIgYW5kIGEgcmFuZ2UgcmV0dXJuIHRoZVxuICogICAgICAgICAgICAgIHZhbHVlIGJldHdlZW4gdGhhdCByYW5nZSBvciB0aGUgbWF4IG51bWJlciBvciBtaW4gbnVtYmVyLlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1pblxuICogQHBhcmFtICB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUgICAgICAgICwgbWluICAgICAgICAsIG1heCAgICAgICAgKSAgICAgICAgIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBNYXRoLm1pbihtaW4sIG1heCkpLCBNYXRoLm1heChtaW4sIG1heCkpO1xufTtcblxuLyoqXG4gKiBAbWVtYmVyT2YgIFV0aWxzXG4gKiBAZGVzY3JpcHRpb24gR2l2ZW4gdHdvIG51bWJlcnMgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSB0d28uXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSB4XG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSB5XG4gKiBAcmV0dXJuIHtJbnRlZ2VyfVxuICovXG5mdW5jdGlvbiByYW5kb21CZXR3ZWVuKHggICAgICAgICwgeSAgICAgICAgKSAgICAgICAgIHtcbiAgbGV0IG1pbiA9IE1hdGgubWluKHgsIHkpO1xuICBsZXQgbWF4ID0gTWF0aC5tYXgoeCwgeSk7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHaXZlbiB0d28gY29vcmRpbmF0ZXMgcmV0dXJuIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28uXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEBwYXJhbSAge051bWJlcn0geDBcbiAqIEBwYXJhbSAge051bWJlcn0geTBcbiAqIEBwYXJhbSAge051bWJlcn0geDFcbiAqIEBwYXJhbSAge051bWJlcn0geTFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2VYWSh4MCAgICAgICAgLCB5MCAgICAgICAgLCB4MSAgICAgICAgLCB5MSAgICAgICAgKSAgICAgICAgIHtcbiAgY29uc3QgZHggPSB4MCAtIHgxO1xuICBjb25zdCBkeSA9IHkwIC0geTE7XG4gIHJldHVybiBNYXRoLmh5cG90KGR4LCBkeSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBnaXZlbiBhIG51bWJlclxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbFxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpblJhbmdlKHZhbCAgICAgICAgLCBtaW4gICAgICAgICwgbWF4ICAgICAgICApICAgICAgICAgIHtcbiAgcmV0dXJuICh2YWwgPD0gTWF0aC5tYXgobWF4LCBtaW4pKSAmJiAoTWF0aC5taW4obWF4LCBtaW4pIDw9IHZhbCk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHaXZlbiBhIHR3byByYW5nZXMgc2VlIGlmIGJvdGggaW50ZXJzZWN0IGVhY2ggb3RoZXIuXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEBwYXJhbSAge051bWJlcn0gbWluMFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXgwXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1pbjFcbiAqIEBwYXJhbSAge051bWJlcn0gbWF4MVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcmFuZ2VJbnRlcnNlY3QobWluMCAgICAgICAgLCBtYXgwICAgICAgICAsIG1pbjEgICAgICAgICwgbWF4MSAgICAgICAgKSAgICAgICAgICB7XG4gIHJldHVybiAoXG4gICAgTWF0aC5tYXgobWF4MCwgbWluMCkgPj0gTWF0aC5taW4obWluMSwgbWF4MSkgJiZcbiAgICBNYXRoLm1pbihtaW4wLCBtYXgwKSA8PSBNYXRoLm1heChtYXgxLCBtaW4xKVxuICApO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2l2ZW4gdHdvIHJlY3RhbmdlIHNlZSBpZiB0aGUgaW50ZXJzZWN0LlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcjBcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSByMVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29sbGlzaW9uUmVjdChyMCAgICAgLCByMSAgICAgKSB7XG4gIGNvbnN0IHIweCA9IHIwLnN0YXRlLng7XG4gIGNvbnN0IHIweSA9IHIwLnN0YXRlLnk7XG4gIGNvbnN0IHIxeCA9IHIxLnN0YXRlLng7XG4gIGNvbnN0IHIxeSA9IHIxLnN0YXRlLnk7XG5cbiAgY29uc3QgcjB3ID0gcjB4ICsgcjAuc3RhdGUud2lkdGg7XG4gIGNvbnN0IHIwaCA9IHIweSArIHIwLnN0YXRlLmhlaWdodDtcbiAgY29uc3QgcjF3ID0gcjF4ICsgcjEuc3RhdGUud2lkdGg7XG4gIGNvbnN0IHIxaCA9IHIxeSArIHIxLnN0YXRlLmhlaWdodDtcblxuICByZXR1cm4gKFxuICAgIHJhbmdlSW50ZXJzZWN0KHIweCwgcjB3LCByMXgsIHIxdykgJiZcbiAgICByYW5nZUludGVyc2VjdChyMHksIHIwaCwgcjF5LCByMWgpXG4gICk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHaXZlbiB0byBwYXJ0aWNsZSB3aXRoIHJhZGkgcmV0dXJuIHdldGhlciB0aGV5IGNvbGxpZGUgYXJlIG5vdFxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gYzFcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBjMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29sbGlzaW9uQ2lyY2xlKGMxICAgICAsIGMyICAgICApICAgICAgICAgIHtcbiAgY29uc3QgcmFkaSA9IChjMS5zdGF0ZS5yYWRpdXMgKyBjMi5zdGF0ZS5yYWRpdXMpO1xuICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlWFkoYzEuc3RhdGUueCwgYzEuc3RhdGUueSwgYzIuc3RhdGUueCwgYzIuc3RhdGUueSk7XG5cbiAgaWYgKGRpc3RhbmNlKSB7XG4gICAgcmV0dXJuIHJhZGkgPiBkaXN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2l2ZW4gYSBwb2ludCBhbmQgYSBjaXJjbGUgcmV0dXJuIGEgYm9vbGVhbiByZWdhcmRpbmcgd2V0aGVyIHRoZXkgYXJlIGNvbGxpZGluZy5cbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQHBhcmFtICB7TnVtYmVyfSAgIHhcbiAqIEBwYXJhbSAge051bWJlcn0gICB5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gY2lyY2xlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjb2xsaXNpb25DaXJjbGVQb2ludCh4ICAgICAgICAsIHkgICAgICAgICwgY2lyY2xlICAgICApIHtcbiAgLy8gVE9ETyBXcml0ZSB0ZXN0cy5cbiAgY29uc3QgZGlzdCA9IGRpc3RhbmNlWFkoXG4gICAgeCxcbiAgICB5LFxuICAgIGNpcmNsZS5zdGF0ZS54LFxuICAgIGNpcmNsZS5zdGF0ZS55XG4gICk7XG5cbiAgcmV0dXJuIGNpcmNsZS5zdGF0ZS5yYWRpdXMgPiBkaXN0O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gZGV0ZWN0IGEgY29sbGlzaW9uIGJldHdlZW4gY2lyY2xlcyBhIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQHBhcmFtICB7VmVjdG9yfSAgIHZlY1xuICogQHBhcmFtICB7UGFydGljbGV9IGNpcmNsZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29sbGlzaW9uQ2lyY2xlVmVjKHZlYyAgICAgICAgLCBjaXJjbGUgICAgICkge1xuICByZXR1cm4gY2lyY2xlLnN0YXRlLnJhZGl1cyA+IGRpc3RhbmNlWFkoXG4gICAgdmVjLmdldChcInhcIiksXG4gICAgdmVjLmdldChcInlcIiksXG4gICAgY2lyY2xlLnN0YXRlLngsXG4gICAgY2lyY2xlLnN0YXRlLnlcbiAgKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIGRldGVjdCBjb2xsaXNpb24gb2YgYSByZWN0YW5nbGUgYW5kIGEgcG9pbnQuXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEBwYXJhbSAge051bWJlcn0gICB4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgeVxuICogQHBhcmFtICB7UGFydGljbGV9IHJlY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbGxpc2lvblJlY3RQb2ludCh4ICAgICAgICAsIHkgICAgICAgICwgcmVjdCAgICAgKSB7XG4gIGNvbnN0IHJlY3RYID0gcmVjdC5zdGF0ZS54O1xuICBjb25zdCByZWN0WSA9IHJlY3Quc3RhdGUueTtcbiAgcmV0dXJuIChcbiAgICBpblJhbmdlKHgsIHJlY3RYLCByZWN0WCArIHJlY3Quc3RhdGUud2lkdGgpICYmXG4gICAgaW5SYW5nZSh5LCByZWN0WSwgcmVjdFkgKyByZWN0LnN0YXRlLmhlaWdodClcbiAgKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdpdmVuIGEgdmVjdG9yIGFuZCBhIHJldGFuZ2xlIGNoZWNrIHdldGhlciB0aGV5IGNvbGxpZGVkLlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtWZWN0b3J9ICAgdmVjXG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcmVjdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29sbGlzaW9uUmVjdFZlYyh2ZWMgICAgICAgICwgcmVjdCAgICAgKSB7XG4gIHJldHVybiBjb2xsaXNpb25SZWN0UG9pbnQodmVjLmdldChcInhcIiksIHZlYy5nZXQoXCJ5XCIpLCByZWN0KTtcbn07XG5cbi8qKlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAZGVzY3JpcHRpb24gUnVuIGEgZnVuY3Rpb24gb25seSBpZiB0aGUgZ2l2ZW4gdGltZSB0byBhbGxvdyB0aGUgZnVuY3Rpb24gZXhlY3V0ZVxuICogaGFzIHBhc3NlZC4gSWZcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmdW5jIEEgZnVuY3Rpb24gdG8gY2FsbCBldmVyeSBkZWx0YS5cbiAqIEBwYXJhbSAge051bWJlcn0gd2FpdCBUaGUgbWluaW11bSB0aW1lIHRvIHdhaXQuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSB1bmRlcnNjb3JlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMgICAgICAgICAgLCB3YWl0ICAgICAgICAsIG9wdGlvbnMgICAgICkge1xuICBsZXQgY29udGV4dDtcbiAgbGV0IGFyZ3MgICAgIDtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICBsZXQgcHJldmlvdXMgPSAwO1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgY29uc3QgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncyAgICAgKSB7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICBsZXQgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IChhcmdzICAgICApO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG4vKipcbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQGRlc2NyaXB0aW9uIC0gU2V0dGluZyB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yLlxuICogQHBhcmFtICAge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0gICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gICB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuICB7bnVtYmVyW119IENvb3JkaW5hdGVzXG4gKi9cbmZ1bmN0aW9uIHNldExlbmd0aChsZW5ndGggICAgICAgICwgeCAgICAgICAgLCB5ICAgICAgICApICAgICAgICAgICAgICAgIHtcbiAgaWYgKHR5cGVvZiB4ICE9PSBcIm51bWJlclwiIHx8XG4gICAgICB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIiB8fFxuICAgICAgdHlwZW9mIGxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIHZhbGlkIHggYW5kIHkgdmFsdWVzXCIpO1xuICB9XG5cbiAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHgpO1xuICB4ID0gTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoO1xuICB5ID0gTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoO1xuXG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vKipcbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQGRlc2NyaXB0aW9uIC0gU2V0dGluZyB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IuXG4gKiBAcGFyYW0gICB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtICAge251bWJlcn0geFxuICogQHBhcmFtICAge251bWJlcn0geVxuICogQHJldHVybiAge251bWJlcltdfSBjb29yZGluYXRlc1xuICovXG5mdW5jdGlvbiBzZXRBbmdsZShhbmdsZSAgICAgICAgLCB4ICAgICAgICAsIHkgICAgICAgICkgICAgICAgICAgICAgICAge1xuICBpZiAodHlwZW9mIHggIT09IFwibnVtYmVyXCIgfHxcbiAgICAgIHR5cGVvZiB5ICE9PSBcIm51bWJlclwiIHx8XG4gICAgICB0eXBlb2YgYW5nbGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB2YWxpZCB4IGFuZCB5IHZhbHVlc1wiKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IE1hdGguaHlwb3QoeCwgeSk7XG4gIHggPSBNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGg7XG4gIHkgPSBNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGg7XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbi8qKlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAZGVzY3JpcHRpb24gQ292ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnNcbiAqIEBwYXJhbSAge251bWJlcn0gZGVnIERlZ3Jlc3NcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVnVG9SYWQoZGVnICAgICAgICApICAgICAgICAge1xuICByZXR1cm4gZGVnIC8gMTgwICogTWF0aC5QSTtcbn07XG5cbi8qKlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAZGVzY3JpcHRpb24gQ292ZXJ0cyByYWRpYW5zIHRvIGRlZ3Jlc3NcbiAqIEBwYXJhbSAge251bWJlcn0gcmFkXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCAgICAgICAgKSAgICAgICAgIHtcbiAgcmV0dXJuIHJhZCAqIDE4MCAvIE1hdGguUEk7XG59O1xuXG4vKipcbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQGRlc2NyaXB0aW9uIFJvdW5kIHRvIG5lYXJlc3QgcGxhY2UgZ2l2ZW4uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtICB7bnVtYmVyfSBwbGFjZXMgQW4gZXhwb25lbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcm91bmRUb1BsYWNlcyh2YWwgICAgICAgICwgcGxhY2VzICAgICAgICApICAgICAgICAge1xuICBjb25zdCBtdWx0ID0gTWF0aC5wb3coMTAsIHBsYWNlcyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIG11bHQpIC8gbXVsdDtcbn07XG5cbi8qKlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtICB7bnVtYmVyfSBuZWFyZXN0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJvdW5kVG9NdWx0aXBsZSh2YWwgICAgICAgICwgbmVhcmVzdCAgICAgICAgKSAgICAgICAgIHtcbiAgaWYgKCFuZWFyZXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90aGluZyBjYW4gYmUgYSBtdWx0aXBsZSBvZiBcIiArIFN0cmluZyhuZWFyZXN0KSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQodmFsIC8gbmVhcmVzdCkgKiBuZWFyZXN0O1xufTtcblxuLyoqXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEBwYXJhbSAge251bWJlcn0gdjBcbiAqIEBwYXJhbSAge251bWJlcn0gdjFcbiAqIEBwYXJhbSAge251bWJlcn0gdjJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSBwRmluYWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcXVhZHJhdGljQmV6aWVyKHYwICAgICAgICAsIHYxICAgICAgICAsIHYyICAgICAgICAsIHQgICAgICAgICkgICAgICAgICB7XG4gIHJldHVybiBNYXRoLnBvdygxIC0gdCwgMikgKiB2MCArICgxIC0gdCkgKiAyICogdCAqIHYxICsgdCAqIHQgKiB2Mjtcbn07XG5cbi8qKlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHYwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHYxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHYyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHYzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gcEZpbmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGN1YmljQmV6aWVyKHYwICAgICAgICAgLCB2MSAgICAgICAgICwgdjIgICAgICAgICAsIHYzICAgICAgICAgLCB0ICAgICAgICAgKSAgICAgICAgIHtcbiAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHYwICtcbiAgICAgICAgIE1hdGgucG93KDEgLSB0LCAyKSAqIDMgKiB0ICogdjEgK1xuICAgICAgICAgKDEgLSB0KSAqIDMgKiB0ICogdCAqIHYyICtcbiAgICAgICAgIHQgKiB0ICogdCArIHYzO1xufTtcblxuLyoqXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7T2JqZWN0fSBwRmluYWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcXVhZHJhdGljQmV6aWVyUG9pbnQocDAgICAgICwgcDEgICAgICwgcDIgICAgICwgdCAgICAgICAgKSB7XG4gIGNvbnN0IHggPSBxdWFkcmF0aWNCZXppZXIocDAueCwgcDEueCwgcDIueCwgdCk7XG4gIGNvbnN0IHkgPSBxdWFkcmF0aWNCZXppZXIocDAueSwgcDEueSwgcDIueSwgdCk7XG4gIHJldHVybiB7eCwgeX07XG59O1xuXG4vKipcbiAqIEBtZW1iZXJPZiBVdGlsc1xuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHBGaW5hbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjdWJpY0JlemllclBvaW50KHAwICAgICAsIHAxICAgICAsIHAyICAgICAsIHAzICAgICAsIHQgICAgICAgICkge1xuICBjb25zdCB4ID0gY3ViaWNCZXppZXIocDAueCwgcDEueCwgcDIueCwgcDMueCwgdCk7XG4gIGNvbnN0IHkgPSBjdWJpY0JlemllcihwMC55LCBwMS55LCBwMi55LCBwMy55LCB0KTtcbiAgcmV0dXJuIHt4LCB5fTtcbn07XG5cbi8qKlxuICogQG1lbWJlck9mIFV0aWxzXG4gKiBAZGVzY3JpcHRpb24gR2l2ZW4gcG9pbnRzIG9uIHRoZSBwbGFuZSBkcmF3IGEgY3VydmVkIGxpbmUgYmV0d2VlblxuICogYWxsIG9mIHRoZW0uXG4gKiBAcGFyYW0gIHt7bnVtYmVyLCBudW1iZXJ9fSBwb2ludHNcbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKi9cbmZ1bmN0aW9uIG11bHRpQ3VydmUocG9pbnRzICAgICAgICAgICAgLCBjdHggICAgICAgICkge1xuICBsZXQgcDA7XG4gIGxldCBwMTtcbiAgbGV0IG1pZFg7XG4gIGxldCBtaWRZO1xuXG4gIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICBwMCA9IHBvaW50c1tpXTtcbiAgICBwMSA9IHBvaW50c1tpICsgMV07XG4gICAgbWlkWCA9IChwMC54ICsgcDEueCkvMjtcbiAgICBtaWRZID0gKHAwLnkgKyBwMS55KS8yO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAwLngsIHAwLnksIG1pZFgsIG1pZFkpO1xuICB9XG5cbiAgcDAgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICBwMSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xufTtcblxuLyoqXG4gKiBlYXNlXG4gKiBAbWVtYmVyT2YgVXRpbHNcbiAqIEBwYXJhbSAge0Zsb2F0fSBlYXNlXG4gKiBAcGFyYW0gIHtJbnR9IGFcbiAqIEBwYXJhbSAge0ludH0gYlxuICogQHBhcmFtICB7bnVtYmVyfSB0aHJlc2hvbGRcbiAqIEByZXR1cm4ge0ludH1cbiAqL1xuZnVuY3Rpb24gZWFzZShlYXNlICAgICAgICAsIGEgICAgICAgICwgYiAgICAgICAgLCB0aHJlc2hvbGQgICAgICAgICA9IDAuMSkgICAgICAgICAgICAgICAgICAge1xuICAvLyB0aGUgZGVsdGEgY2FuIGdldCBleHRyZW1lbHkgc21hbGwgYW5kIGl0cyBub3QgcGVyZm9ybWFudCB0byBrZWVwXG4gIC8vIG9uIHJlbmRlcmluZyBvciBjYWxjdWxhdGluZyBmb3IgYW5pbWF0aW9uIHB1cnBvc2VzLlxuICBpZiAoTWF0aC5hYnMoYiAtIGEpIDwgdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIChiIC0gYSkgKiBlYXNlO1xufTtcblxuLyoqXG4gKiBlYXNlVG9cbiAqIEBwYXJhbSAge251bWJlcn0gZWFzZTogICAgICBudW1iZXIgICAgICAgIEVhc2UgZmFjdG9yLlxuICogQHBhcmFtICB7T2JqZWN0fSBvcmlnaW46ICAgIE9iamVjdCAgICAgICAgVGhlIHN0YXJ0aW5nIHBvaW50LlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXQ6ICAgIE9iamVjdCAgICAgICAgVGhlIGVuZGluZyBwb2ludC5cbiAqIEBwYXJhbSAge051bWJlcn0gdGhyZXNob2xkOiBudW1iZXIgICAgICAgIEVhc2luZyB0aHJlc2hvbGQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVhc2VUbyhlYXNlICAgICAgICAsIG9yaWdpbiAgICAgICAgLCB0YXJnZXQgICAgICAgICwgdGhyZXNob2xkICAgICAgICA9MC4xKSB7XG4gIGNvbnN0IGR4ID0gdGFyZ2V0LnggLSBvcmlnaW4ueDtcbiAgY29uc3QgZHkgPSB0YXJnZXQueSAtIG9yaWdpbi55O1xuXG4gIC8vIHRoZSBkZWx0YSBjYW4gZ2V0IGV4dHJlbWVseSBzbWFsbCBhbmQgaXRzIG5vdCBwZXJmb3JtYW50IHRvIGtlZXBcbiAgLy8gb24gcmVuZGVyaW5nIG9yIGNhbGN1bGF0aW5nIGZvciBhbmltYXRpb24gcHVycG9zZXMuXG4gIGlmIChNYXRoLmFicyhkeCkgPCB0aHJlc2hvbGQgJiYgTWF0aC5hYnMoZHkpIDwgdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgb3JpZ2luLnggKz0gZHggKiBlYXNlO1xuICBvcmlnaW4ueSArPSBkeSAqIGVhc2U7XG5cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbi8qKlxuICogaXNQbGFpbk9iamVjdFxuICogQHBhcmFtICB7Kn0gIGRhdGFcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KGRhdGEgICAgICkgICAgICAgICAge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgKHt9KS50b1N0cmluZy5jYWxsKGRhdGEpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufTtcblxuLyoqXG4gKiB1bmlxdWUgcmV0dXJuIGFuIGFycmF5IHdpdGggbm8gZHVwbGljYXRlIHZhbHVlc1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gdW5pcXVlKGFycmF5ICAgICAgICAgICAgKSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHgsIHkpID0+IHtcbiAgICBpZiAoeC5pbmRleE9mKHkpID09PSAtMSkgeC5wdXNoKHkpO1xuICAgIHJldHVybiB4O1xuICB9LCBbXSk7XG59O1xuXG4vLyBmdW5jdGlvbiBjb2xvckludGVycG9sYXRpb24oZmxvYXQ6IG51bWJlciwgY29sb3JGcm9tOiBDb2xvciwgY29sb3JUbzogQ29sb3IpIDogQ29sb3Ige1xuLy8gICBjb25zdCB7cjEsIGcxLCBiMX0gPSBjb2xvckZyb207XG4vLyAgIGNvbnN0IHtyMiwgZzIsIGIyfSA9IGNvbG9yVG87XG5cbi8vICAgY29uc3QgciA9IHIxICsgKHIyIC0gcjEpIC8gZmxvYXQ7XG4vLyAgIGNvbnN0IGcgPSBnMSArIChnMiAtIGcxKSAvIGZsb2F0O1xuLy8gICBjb25zdCBiID0gYjEgKyAoYjIgLSBiMSkgLyBmbG9hdDtcblxuLy8gICByZXR1cm4gXCJzb21lSGV4XCI7XG4vLyB9O1xuXG4vKipcbiAqIHBlcnNwZWN0aXZlIC0gcGVyc3BlY3RpdmUgaXMgdGhlIHJhdGlvIHRvIG11bHRpcGx5IHRoZSB4IGFuZCB5IHZhbHVlc1xuICogYnkgdG8gZ2V0IHRob3NlIHBvaW50cyByZXByZXNlbmV0ZWQgaW4gM2Qgc3BhY2UuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGZvY2FsTGVuZ3RoOiBUaGUgbGVuZ3RoIG9mIHRoZSBsZW5zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRpc3RhbmNlOiAgICBUaGUgZGlzdGFuY2UgZnJvbSBiZWdpbmluZyBvZiB0aGUgbGVucyB0aGUgdGhlIGJlZ2luZ2luZyBvZiB0aGUgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfWBgXG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKGZvY2FsTGVuZ3RoICAgICAgICAsIGRpc3RhbmNlICAgICAgICApICAgICAgICAge1xuICByZXR1cm4gZm9jYWxMZW5ndGggLyAoZm9jYWxMZW5ndGggLSBkaXN0YW5jZSk7XG59O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsc1xuICogQHJldHVybiB7VXRpbHN9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vcm1hbGl6ZSxcbiAgbGVycCxcbiAgbWFwLFxuICBwZXJjZW50LFxuICBjbGFtcCxcbiAgcmFuZG9tQmV0d2VlbixcbiAgZGlzdGFuY2VYWSxcbiAgaW5SYW5nZSxcbiAgcmFuZ2VJbnRlcnNlY3QsXG4gIGNvbGxpc2lvblJlY3QsXG4gIGNvbGxpc2lvbkNpcmNsZSxcbiAgY29sbGlzaW9uQ2lyY2xlUG9pbnQsXG4gIGNvbGxpc2lvbkNpcmNsZVZlYyxcbiAgY29sbGlzaW9uUmVjdFBvaW50LFxuICBjb2xsaXNpb25SZWN0VmVjLFxuICB0aHJvdHRsZSxcbiAgc2V0TGVuZ3RoLFxuICBzZXRBbmdsZSxcbiAgZGVnVG9SYWQsXG4gIHJhZFRvRGVnLFxuICByb3VuZFRvUGxhY2VzLFxuICByb3VuZFRvTXVsdGlwbGUsXG4gIHF1YWRyYXRpY0JlemllcixcbiAgY3ViaWNCZXppZXIsXG4gIHF1YWRyYXRpY0JlemllclBvaW50LFxuICBjdWJpY0JlemllclBvaW50LFxuICBtdWx0aUN1cnZlLFxuICBwZXJzcGVjdGl2ZSxcbiAgZWFzZSxcbiAgZWFzZVRvLFxuICBpc09iamVjdCxcbiAgdW5pcXVlLFxufTtcblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKFV0aWxzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvdXRpbHMuanMiLCIvLyAgICAgIFxuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG4vKlxuKiBUaGUgcGFydGljbGUgbGliYXJ5IGlzIHVzZWQgZm9yIHBoeXNpY3MgYW5pbWF0aW9ucy5cbiogdGhleSBhcmUgbm90IGV4dHJlbWVseSBhY2N1cmF0ZSBidXQgc3RpbGwgcmVwcmVzZW50XG4qIGFuZCBmZWVsIHNvbWV3aGF0IGxpa2UgcGh5c2ljYWwgbW92bWVudHMuXG4qL1xuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKFwiZXh0ZW5kXCIpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKTtcblxuXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgXG4gICAgXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICBcbiAgXG5cblxuLyogVGhlIGRlZmF1bHQgc3RhdGUgYSBwYXJ0aWNsZSBzdGFydHMgd2l0aCBJdCBzaG91bGQgbm90IG1vdmUuICovXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICBcbiAgXG5cbmNvbnN0IElOSVRJQUxfU1RBVEUgICAgICAgID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB2eDogMCxcbiAgdnk6IDAsXG4gIGdyYXZpdHk6IDAsXG4gIG1hZ25pdHVkZTogMCxcbiAgcmFkaXVzOiAxLFxuICBtYXNzOiAxLFxuICBkaXJlY3Rpb246IE1hdGguUEkgKiAyLFxuICBmcmljdGlvbjogMSxcbiAgc3ByaW5nczogW10sXG4gIG1hc3NlczogW10sXG4gIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgd2lkdGg6IDEwLFxuICBoZWlnaHQ6IDEwLFxufTtcblxuLyoqXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBwYXJhbSB7c3RhdGV9IHN0YXRlIGluaXRpYWwgc3RhdGUgdG8gcGFzcyB0aGUgY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUGFydGljbGUge1xuICAgICAgICAgICAgICAgXG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtzdGF0ZX0gc3RhdGUgUGFydGljbGUgc3RhdGUgY29vcmRpbmF0ZXMsIGV0Yy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0YXRlICAgICAgID1jbG9uZShJTklUSUFMX1NUQVRFKSkgICAgICAge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgfTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIHBhcnRpY2xlIGdpdmVuIGEgZGlyZWN0aW9uIGFuZCBtYWduaXR1ZGUuXG4gICAqIEBtZW1iZXJPZiBQYXJ0aWNsZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgc3RhdGUgb3B0aW9uYWwgc3RhdGUgdmFsdWVzIHRvIHBhc3MgdG8gY3JlYXRlLlxuICAgKiBAcmV0dXJuIHtQYXJ0aWNsZX0gcmV0dXJucyBhIHBhcnRpY2xlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKHN0YXRlICAgICAgICA9IGNsb25lKElOSVRJQUxfU1RBVEUpKSAgICAgICAgICAge1xuICAgIC8vIEV4dGVuZCB0aGUgb3B0aW9uYWwgc3RhdGUgb24gdG8gdGhlIGRlZmF1bHQgc3RhdGUuXG4gICAgc3RhdGUgPSBleHRlbmQodHJ1ZSwgY2xvbmUoSU5JVElBTF9TVEFURSksIHN0YXRlKTtcblxuICAgIC8vIENyZWF0ZSBwYXJ0aWNsZSB3aXRoIHRoZSBuZXcgb3B0aW9ucy5cbiAgICBjb25zdCBwYXJ0aWNsZSA9IG5ldyBQYXJ0aWNsZShzdGF0ZSk7XG5cbiAgICAvLyBTZXQgbGVuZ3RoLlxuICAgIHBhcnRpY2xlLnNldFNwZWVkKHN0YXRlLm1hZ25pdHVkZSk7XG5cbiAgICAvLyBTZXQgYW5nbGUuXG4gICAgcGFydGljbGUuc2V0SGVhZGluZyhzdGF0ZS5kaXJlY3Rpb24pO1xuXG4gICAgLy8gUmV0dXJuIG5ldyBwYXJ0aWNsZS5cbiAgICByZXR1cm4gcGFydGljbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBQYXJ0aWNsZVxuICAgKiBAZGVzY3JpcHRpb24gZ2VuZXJhdGUgYSBidW5jaCBvZiBwYXJ0aWNsZXMuXG4gICAqIEBwYXJhbSAge051bWJlcn0gbnVtYmVyICAgIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBnZW5lcmF0ZWQgcGFydGljbGVzIG5lZWRlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzICAgICAgT3B0aW9ucyB0byBwYXNzIGVhY2ggcGFydGljbGVcbiAgICogQHJldHVybiB7QXJyYXk8UGFydGljbGU+fVxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKG51bWJlciAgICAgICAgLCBvcHRzICAgICAgID1jbG9uZShJTklUSUFMX1NUQVRFKSkgICAgICAgICAgICAgICAgICB7XG4gICAgY29uc3QgcGFydGljbGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlcjsgaSsrKSB7XG4gICAgICBwYXJ0aWNsZXMucHVzaChQYXJ0aWNsZS5jcmVhdGUob3B0cykpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJ0aWNsZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNoYW5nZSBpbiB2ZWxvY2l0eS5cbiAgICpcbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBwYXJhbSAge0ludGVnZXJ9IGF4XG4gICAqIEBwYXJhbSAge0ludGVnZXJ9IGF5XG4gICAqIEByZXR1cm4ge3ZvaWR9IEFjY2VsZXJhdGlvbiB2ZWN0b3IuXG4gICAqL1xuICBhY2NlbGVyYXRlKGF4ICAgICAgICA9dGhpcy5zdGF0ZS52eCwgYXkgICAgICAgID10aGlzLnN0YXRlLnZ5KSAgICAgICB7XG4gICAgdGhpcy5zdGF0ZS52eCArPSBheDtcbiAgICB0aGlzLnN0YXRlLnZ5ICs9IGF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQSB1cGRhdGUgYSBwb3NpdGlvbiBvZiBhIHBhcnRpY2xlXG4gICAqIGJhc2VkIG9uIGl0cyBncmF2aXR5IGFuZCBmcmljaXRpb24uIEdyYXZpdHkgaXMgdXN1YWxseSBhIGFjY2VsZXJhdGlvblxuICAgKiB2ZWN0b3IuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBQYXJ0aWNsZVxuICAgKiBAcGFyYW0gIHtJbnRlZ2VyfSBmcmljIEZyaWNpdGlvbiB0byBhcHBseS5cbiAgICogQHBhcmFtICB7SW50ZWdlcn0gZ3JhdiBHcmF2aXR5IHRvIGFwcGx5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFBvc2l0aW9uIHN0YXRlLlxuICAgKi9cbiAgdXBkYXRlKGZyaWMgICAgICAgICA9IHRoaXMuc3RhdGUuZnJpY3Rpb24sIGdyYXYgICAgICAgICA9IHRoaXMuc3RhdGUuZ3Jhdml0eSkge1xuICAgIC8vIEFwcGx5IHNwcmluZ3NcbiAgICB0aGlzLmhhbmRsZVNwcmluZ3MoKTtcblxuICAgIC8vIEFwcGx5IGdyYXZpdGF0aW9uc1xuICAgIHRoaXMuaGFuZGxlTWFzc2VzKCk7XG5cbiAgICAvLyBBcHBseSBmYWtlIGZyaWNpdGlvbiB0byB2ZWxvY2l0eVxuICAgIHRoaXMuc3RhdGUudnggKj0gZnJpYztcbiAgICB0aGlzLnN0YXRlLnZ5ICo9IGZyaWM7XG5cbiAgICAvLyBBcHBseSBncmF2aXR5IHRvIHZlbG9jaXR5XG4gICAgdGhpcy5hY2NlbGVyYXRlKDAsIGdyYXYpO1xuXG4gICAgLy8gVXBkYXRlIHBvc2l0aW9uIGJhc2VkIG9uIGFjY2VsZXJhdGlvblxuICAgIHJldHVybiB0aGlzLnVwZGF0ZVBvcygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gc2V0cyB0aGUgaW50ZXJuYWwgc3BlZWQgb2YgdGhlIHBhcnRpY2xlIGdpdmVuIHRoZSBmb3JjZVxuICAgKiBAbWVtYmVyT2YgUGFydGljbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXG4gICAqL1xuICBzZXRTcGVlZChzcGVlZCAgICAgICAgKSAgICAgICB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEhlYWRpbmcoKTtcbiAgICB0aGlzLnN0YXRlLnZ4ID0gTWF0aC5jb3MoYW5nbGUpICogc3BlZWQ7XG4gICAgdGhpcy5zdGF0ZS52eSA9IE1hdGguc2luKGFuZ2xlKSAqIHNwZWVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgUGFydGljbGVcbiAgICogQGRlc2NyaXB0aW9uIHNldHMgdGhlIGludGVybmFsIHNwZWVkIG9mIHRoZSBwYXJ0aWNsZSBnaXZlbiB0aGUgYW5nbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAqL1xuICBzZXRIZWFkaW5nKGFuZ2xlICAgICAgICApICAgICAgIHtcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMuZ2V0U3BlZWQoKTtcbiAgICB0aGlzLnN0YXRlLnZ4ID0gTWF0aC5jb3MoYW5nbGUpICogc3BlZWQ7XG4gICAgdGhpcy5zdGF0ZS52eSA9IE1hdGguc2luKGFuZ2xlKSAqIHNwZWVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlbG9jaXR5IHZlY3Rvci5cbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bnVtYmVyfSBmb3JjZSBvZiB2ZWxvY2l0eSB2ZWN0b3IuXG4gICAqL1xuICBnZXRTcGVlZCh4ICAgICAgICAgPSB0aGlzLnN0YXRlLnZ4LCB5ICAgICAgICAgPSB0aGlzLnN0YXRlLnZ5KSAgICAgICAgIHtcbiAgICByZXR1cm4gTWF0aC5oeXBvdCh0aGlzLnN0YXRlLnZ4LCB0aGlzLnN0YXRlLnZ5KTtcbiAgfTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGdldCB0aGUgYW5nbGUgb2YgdGhlIHZlbG9jaXR5IHZlY3Rvci5cbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bnVtYmVyfSBhbmdsZSBvZiB2ZWxvY2l0eSB2ZWN0b3IuXG4gICAqL1xuICBnZXRIZWFkaW5nKHggICAgICAgICA9IHRoaXMuc3RhdGUudngsIHkgICAgICAgICA9IHRoaXMuc3RhdGUudnkpICAgICAgICAge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQXN1bW1pbmcgd2Uga25vdyB3aGVyZVxuICAgKiB0aGUgb3RoZXIgcGFydGljbGUgaXMgb24gdGhlIGNhbnZhcy4gV2UgY2FuIHVzZVxuICAgKiB0aGUgYW5nbGUgZm9ybXVsYWUgdG8gZmlndXJlIG91dCB0aGUgYW5nbGVcbiAgICogYmV0d2VlbiB0d28gcGFydGljbGUuIFVzaW5nIGFyY3RhbmdlbnQgaXMgZmluZS5cbiAgICogYnV0IGJlY2F1c2UgdGhlIGNvcnJkaW5hdGUgcGxhbmUgaXMgZmlscGVkIG9uIHRoZVxuICAgKiBZIGF4aXMgd2UgdXNlIGF0YW4yIHRvIGdldCB0aGUgcmlnaHQgdmFsdWVzLiBFeHBsYWluZWRcbiAgICogaW4gQVBJIERvY3MuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBQYXJ0aWNsZVxuICAgKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcCAgICAgIEEgcGFydGljbGUgaW5zdGFuY2UuXG4gICAqIEByZXR1cm4ge0ludGVnZXJ9ICBBbmdsZSAgIEEgYW5nbGUuXG4gICAqL1xuICBhbmdsZVRvKHAgICAgICAgICAgKSAgICAgICAgIHtcbiAgICBjb25zdCBkeCA9IHAuc3RhdGUueCAtIHRoaXMuc3RhdGUueDtcbiAgICBjb25zdCBkeSA9IHAuc3RhdGUueSAtIHRoaXMuc3RhdGUueTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihkeSwgZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQXNzdW1pbmcgd2Uga25vdyB3aGVyZSBib3RoIHBhcnRpY2xlIGFyZSBvbiB0aGUgY2FudmFzLlxuICAgKiB3ZSBjYW4gdXNlIHRoZSBkaXN0YW5jZSBmb3JtdWFsZSB0byBmaWd1cmUgb3V0IHRoZSBkaXN0YW5jZVxuICAgKiBiZXR3ZWVuIHRoZSB0d28gcGFydGljbGVzLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgUGFydGljbGVcbiAgICogQHBhcmFtICB7UGFydGljbGV9IHAgICAgICBBIHBhcnRpY2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge251bWJlcn0gIEFuZ2xlICAgQSBEaXN0YW5jZVxuICAgKi9cbiAgZGlzdGFuY2VUbyhwICAgICAgICAgICkgICAgICAgICB7XG4gICAgY29uc3QgZHggPSBwLnN0YXRlLnggLSB0aGlzLnN0YXRlLng7XG4gICAgY29uc3QgZHkgPSBwLnN0YXRlLnkgLSB0aGlzLnN0YXRlLnk7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBkZXNjcmlwdGlvbiBBcHBlbmQgYSBwYXJ0aWNsZSB0byB0aGUgbWFzc2VzIGFycmF5LlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBtYXNzXG4gICAqL1xuICBhZGRNYXNzKG1hc3MgICAgICAgICAgKSAgICAgICB7XG4gICAgdGhpcy5yZW1vdmVNYXNzKG1hc3MpO1xuICAgIHRoaXMuc3RhdGUubWFzc2VzLnB1c2gobWFzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBQYXJ0aWNsZVxuICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIGEgcGFydGljbGUgZm9yIHRoZSBtYXNzZXMgYXJyYXkuXG4gICAqIEBwYXJhbSAge1BhcnRpY2xlfSBtYXNzXG4gICAqL1xuICByZW1vdmVNYXNzKHtzdGF0ZTogbWFzc30gICAgICAgICAgKSAgICAgICB7XG4gICAgY29uc3QgbWFzc2VzID0gdGhpcy5zdGF0ZS5tYXNzZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1hc3MueCA9PT0gbWFzc2VzW2ldLnN0YXRlLnggJiZcbiAgICAgICAgICBtYXNzLnkgPT09IG1hc3Nlc1tpXS5zdGF0ZS55KSB7XG4gICAgICAgIG1hc3Nlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBkZXNjcmlwdGlvbiBBcHBseXMgZ3Jhdml0YXRpb24gdG8gdGhlIGlucHV0IHBhcnRpY2xlLlxuICAgKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcGFydGljbGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ3Jhdml0YXRlVG8ocGFydGljbGUgICAgICAgICAgKSAgICAgICB7XG4gICAgY29uc3QgZHggPSBwYXJ0aWNsZS5zdGF0ZS54IC0gdGhpcy5zdGF0ZS54O1xuICAgIGNvbnN0IGR5ID0gcGFydGljbGUuc3RhdGUueSAtIHRoaXMuc3RhdGUueTtcblxuICAgIC8vIERpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwYXJ0aWNsZXNcbiAgICAvLyB3ZSBkb250IHVzZSB0aGUgZGlzdGFuY2VUbyBmbiBjYXVzZSB3ZSB3YW50XG4gICAgLy8gdG8gb3B0aW16aWUgdGhlIGNvZGUgdG8gbm90IGhhdmUgdG8gY2FsY3VsYXRlXG4gICAgLy8gZGlzdFNxcmQgYWdhaW4uXG4gICAgY29uc3QgZGlzdFNxcmQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGRpc3RTcXJkKTtcblxuICAgIC8vIE1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIFtGID0gRyhtMSkobTIpL3JeMl1cbiAgICBjb25zdCBmb3JjZSA9IHBhcnRpY2xlLnN0YXRlLm1hc3MgLyBkaXN0U3FyZDtcblxuICAgIC8vIFNldHRpbmcgdXAgYW5nbGVzIG9mIHRoZSB2ZWN0b3JcbiAgICBjb25zdCBzaW4gPSBkeSAvIGRpc3Q7XG4gICAgY29uc3QgY29zID0gZHggLyBkaXN0O1xuXG4gICAgLy8gU2V0dGluZyB2ZXRvciBhbmdsZVxuICAgIGNvbnN0IGF4ID0gY29zICogZm9yY2U7XG4gICAgY29uc3QgYXkgPSBzaW4gKiBmb3JjZTtcblxuICAgIHJldHVybiB0aGlzLmFjY2VsZXJhdGUoYXgsIGF5KTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBkZXNjcmlwdGlvbiBBcHBseSB2ZWxvY2l0eSB0byB0aGUgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0ludGVnZXJ9IHZ4XG4gICAqIEBwYXJhbSAge0ludGVnZXJ9IHZ5XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICB1cGRhdGVQb3ModnggICAgICAgICAsIHZ5ICAgICAgICAgKSAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgaWYgKHZ4ID09PSB1bmRlZmluZWQgJiYgdnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGF0ZS54ICs9IHRoaXMuc3RhdGUudng7XG4gICAgICB0aGlzLnN0YXRlLnkgKz0gdGhpcy5zdGF0ZS52eTtcbiAgICAgIHJldHVybiB7eDogdGhpcy5zdGF0ZS54LCB5OiB0aGlzLnN0YXRlLnl9O1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUueCArPSB2eDtcbiAgICB0aGlzLnN0YXRlLnkgKz0gdnk7XG4gICAgcmV0dXJuIHt4OiB0aGlzLnN0YXRlLngsIHk6IHRoaXMuc3RhdGUueX07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBhZGQgc3ByaW5nIHRvIHNwcmluZ3MgYXJyYXlcbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcHJpbmcgQSBzcHJpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGFkZFNwcmluZyhzcHJpbmcgICAgICAgICkgICAgICAgICB7XG4gICAgdGhpcy5yZW1vdmVTcHJpbmcoc3ByaW5nKTtcbiAgICB0aGlzLnN0YXRlLnNwcmluZ3MucHVzaChzcHJpbmcpO1xuICAgIHJldHVybiBzcHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiByZW1vdmUgYSBzcGVjaWZpYyBzdHJpbmcgZnJvbSB0aGUgc3ByaW5ncyBhcnJheVxuICAgKiBAbWVtYmVyT2YgUGFydGljbGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzcHJpbmdcbiAgICovXG4gIHJlbW92ZVNwcmluZyh7cG9pbnQ6IHtzdGF0ZTogcH19ICAgICAgICApICAgICAgIHtcbiAgICBjb25zdCBzcHJpbmdzID0gdGhpcy5zdGF0ZS5zcHJpbmdzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocC54ID09PSBzcHJpbmdzW2ldLnBvaW50LnN0YXRlLnggJiZcbiAgICAgICAgICBwLnkgPT09IHNwcmluZ3NbaV0ucG9pbnQuc3RhdGUueSkge1xuICAgICAgICBzcHJpbmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgUGFydGljbGVcbiAgICogQGRlc2NyaXB0aW9uIEdpdmVuIHR3byBwYXJ0aWNsZXMgY2FsY3VsYXRlIHRoZVxuICAgKiBzcHJpbmcgZm9yY2UgYXBwbGllZCB0byBib3RoIHBhcnRpY2xlcy5cbiAgICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlXG4gICAqIEBwYXJhbSAge0ludGVnZXJ9ICBzcHJpbmd5ICBHaXZlbiBvZmZzZXQgZm9yIHRoZSBwYXJ0aWNsZXNcbiAgICogQHBhcmFtICB7SW50ZWdlcn0gIG9mZnNldCAgVGhlIHNwcmluZyBjb2VmZmljZW50XG4gICAqIEByZXR1cm4ge1BhcnRpY2xlW119XG4gICAqL1xuICBzcHJpbmdGcm9tVG8ocGFydGljbGUgICAgICAgICAgLCBzcHJpbmd5ICAgICAgICAgPSAwLjA1LCBvZmZzZXQgICAgICAgICA9IDEwMCkgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAvLyBQb3N0aW9uIGRlbHRhXG4gICAgY29uc3QgZHggPSAocGFydGljbGUuc3RhdGUueCAtIHRoaXMuc3RhdGUueCk7XG4gICAgY29uc3QgZHkgPSAocGFydGljbGUuc3RhdGUueSAtIHRoaXMuc3RhdGUueSk7XG5cbiAgICAvLyBTZXR0aW5nIHVwIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5oeXBvdChkeCwgZHkpO1xuICAgIGNvbnN0IHNwcmluZ0ZvcmNlID0gKGRpc3RhbmNlIC0gb2Zmc2V0KSAqIHNwcmluZ3k7XG5cbiAgICAvLyBTcHJpbmcgYWNjZWxlcmF0aW9uIHZlY3RvclxuICAgIGNvbnN0IHN4ID0gZHggLyBkaXN0YW5jZSAqIHNwcmluZ0ZvcmNlO1xuICAgIGNvbnN0IHN5ID0gZHkgLyBkaXN0YW5jZSAqIHNwcmluZ0ZvcmNlO1xuXG4gICAgLy8gQWNjZWxlcmF0ZSB3aXRoIHRoZSBzcHJpbmcgdmVjdG9yXG4gICAgdGhpcy5hY2NlbGVyYXRlKHN4LCBzeSk7XG5cbiAgICAvLyBBY2NlbGVyYXRlIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgcGFydGljbGUuc3RhdGUudnggLT0gc3g7XG4gICAgcGFydGljbGUuc3RhdGUudnkgLT0gc3k7XG5cbiAgICByZXR1cm4gW3RoaXMsIHBhcnRpY2xlXTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlck9mIFBhcnRpY2xlXG4gICAqIEBkZXNjcmlwdGlvbiBHaXZlbiBhIHBhcnRpY2xlLCBhIHZlY3RvciwgYW5kIGEgc3ByaW5nIGNvZWZmaWVuY2VudCBhY2NlbGVyYXRlXG4gICAqIHRoZSBwYXJ0aWNsZSBhY2NvcmRpbmcgdG8gdGhlIGRpc3RhbmNlIGl0cyBpcyBmcm9tIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7U3ByaW5nfSBzcHJpbmcgQSBzcHJpbmcgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtQYXJ0aWNsZX1cbiAgICovXG4gIHNwcmluZ1RvUG9pbnQoc3ByaW5nICAgICAgICApICAgICAgICAgICAgICAgICAgICAge1xuICAgIC8vIFBvc3Rpb24gZGVsdGFcbiAgICBjb25zdCBkeCA9IChzcHJpbmcucG9pbnQuc3RhdGUueCAtIHRoaXMuc3RhdGUueCk7XG4gICAgY29uc3QgZHkgPSAoc3ByaW5nLnBvaW50LnN0YXRlLnkgLSB0aGlzLnN0YXRlLnkpO1xuXG4gICAgLy8gU2V0dGluZyB1cCBtYWduaXR1ZGUgYW5kIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgICBjb25zdCBzcHJpbmdGb3JjZSA9IChkaXN0YW5jZSAtIHNwcmluZy5vZmZzZXQpICogc3ByaW5nW1wic3ByaW5nXCJdO1xuXG4gICAgLy8gU3ByaW5nIGFjY2VsZXJhdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBzeCA9IGR4IC8gZGlzdGFuY2UgKiBzcHJpbmdGb3JjZTtcbiAgICBjb25zdCBzeSA9IGR5IC8gZGlzdGFuY2UgKiBzcHJpbmdGb3JjZTtcblxuICAgIC8vIEFjY2VsZXJhdGUgd2l0aCB0aGUgc3ByaW5nIHZlY3RvclxuICAgIHRoaXMuYWNjZWxlcmF0ZShzeCwgc3kpO1xuXG4gICAgcmV0dXJuIFt0aGlzLCBzcHJpbmddO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgUGFydGljbGVcbiAgICogQGRlc2NyaXB0aW9uIEFwcGx5IHNwcmluZyBwb2ludCB0byBhbGwgaW50ZXJuYWwgc3ByaW5ncy5cbiAgICogQHBhcmFtICB7c3ByaW5nc30gc3ByaW5ncyBBbiBhcnJheSBvZiBzcHJpbmdzIHRvIHNwcmluZyB0by5cbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBoYW5kbGVTcHJpbmdzKHNwcmluZ3MgICAgICAgICAgICAgICA9dGhpcy5zdGF0ZS5zcHJpbmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnNwcmluZ1RvUG9pbnQoc3ByaW5nc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwcmluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBQYXJ0aWNsZVxuICAgKiBAZGVzY3JpcHRpb24gRm9yIGVhY2ggbWFzcyBpbiB0aGUgbWFzc2VzIGFycmF5IGFwcGx5IGdyYXZpdGF0ZSB0byBpdC5cbiAgICogQHBhcmFtICB7UGFydGljbGVzW118T2JqZWN0W119IG1hc3Nlc1xuICAgKiBAcmV0dXJuIHtQYXJ0aWNsZXNbXXxPYmplY3RbXX1cbiAgICovXG4gIGhhbmRsZU1hc3NlcyhtYXNzZXMgICAgICAgICAgICAgICAgID10aGlzLnN0YXRlLm1hc3Nlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmdyYXZpdGF0ZVRvKG1hc3Nlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc3NlcztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL3BhcnRpY2xlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcblx0aWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcblx0fVxuXG5cdHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG5cdGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd24uY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xuXHR2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlICYmIGhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG5cdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0aWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duQ29uc3RydWN0b3IgJiYgIWhhc0lzUHJvdG90eXBlT2YpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iaikgey8qKi99XG5cblx0cmV0dXJuIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdLFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdib29sZWFuJykge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fSBlbHNlIGlmICgodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykgfHwgdGFyZ2V0ID09IG51bGwpIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzW2ldO1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAob3B0aW9ucyAhPSBudWxsKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbbmFtZV07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zW25hbWVdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKHRhcmdldCAhPT0gY29weSkge1xuXHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdGlmIChkZWVwICYmIGNvcHkgJiYgKGlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gaXNBcnJheShjb3B5KSkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBleHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvcHkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBjb3B5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0ZW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvY2xvbmVEZWVwLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VDbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX1N0YWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19MaXN0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2VxLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0YWNrQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0YWNrSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3Jvb3QuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2ZyZWVHbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzTWFza2VkLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY29yZUpzRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19NYXBDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19IYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzaERlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0tleWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXJyYXlFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VBc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jb3B5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2tleXMuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9zdHViRmFsc2UuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNMZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlVW5hcnkuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19ub2RlVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19vdmVyQXJnLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlQXNzaWduSW4uanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gva2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19uYXRpdmVLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2xvbmVCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2NvcHlBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY29weVN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRTeW1ib2xzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcnJheUZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL3N0dWJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY29weVN5bWJvbHNJbi5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRTeW1ib2xzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcnJheVB1c2guanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldEFsbEtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19EYXRhVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX1Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19TZXQuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19XZWFrTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faW5pdENsb25lQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lTWFwID0gcmVxdWlyZSgnLi9fY2xvbmVNYXAnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTZXQgPSByZXF1aXJlKCcuL19jbG9uZVNldCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19VaW50OEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWRkTWFwRW50cnkgPSByZXF1aXJlKCcuL19hZGRNYXBFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIENMT05FX0RFRVBfRkxBRykgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2xvbmVNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBtYXBgLlxuICovXG5mdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBtYXAuc2V0YCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRNYXBFbnRyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXJyYXlSZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFkZFNldEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkU2V0RW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHNldC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTZXQoc2V0LCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMoc2V0VG9BcnJheShzZXQpLCBDTE9ORV9ERUVQX0ZMQUcpIDogc2V0VG9BcnJheShzZXQpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZFNldEVudHJ5LCBuZXcgc2V0LmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYWRkU2V0RW50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zZXRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jbG9uZVN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGVzbGludCBtYXgtbGVuOiAwICovXG5cbi8vICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbi8qKlxuICogQGNsYXNzIFNoYXBlc1xuICogQHBhcmFtIHtPYmplY3R9IGN0eCAgICAgIENhbnZhcyBjb250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IGRvY3VtZW50IFRoZSBkb2N1bWVudCBvYmplY3QuXG4qL1xuY2xhc3MgU2hhcGVzIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICBcblxuICAvKipcbiAgICogY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7SFRNTENhbnZhc0VsZW1lbnR9IGN0eFxuICAgKiBAcGFyYW0gIHtEb2N1bWVudH0gZG9jdW1lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGN0eCAgICAgICAgICAgICAgICAgICAgICAgICAgLCBkb2N1bWVudCAgICAgICAgICApIHtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGVzOiBQbGVhc2UgcHJvdmlkZSBhIGNvbnRleHQgYXJndW1lbnQgW2FyZzo6MV1cIik7XG4gICAgfVxuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgU2hhcGVzXG4gICAqIEBkZXNjcmlwdGlvbiBkcmF3IGEgY2lyY2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCAgICAgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geSAgICAgVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gciAgICAgVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBjaXJjbGUuXG4gICAqL1xuICBjaXJjbGUoeCAgICAgICAgPTQsIHkgICAgICAgID00LCByICAgICAgICA9MiwgY29sb3IgICAgICAgPVwiIzAwMDAwMFwiKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgdGhpcy5jdHguZmlsbCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyT2YgU2hhcGVzXG4gICAqIEBkZXNjcmlwdGlvbiBGaWxsIGEgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgICAgU3RhcnRpbmcgcG9pbnQgWFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgIFN0YXJ0aW5nIHBvaW50IFlcbiAgICogQHBhcmFtICB7TnVtYmVyfSB3ICAgICBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSAge051bWJlcn0gaCAgICAgSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjb2xvciBBIGhleCBzdHJpbmcuXG4gICAqL1xuICByZWN0KHggICAgICAgICA9IDAsXG4gICAgICB5ICAgICAgICAgPSAwLFxuICAgICAgdyAgICAgICAgID0gMTAsXG4gICAgICBoICAgICAgICAgPSAxMCxcbiAgICAgIGNvbG9yICAgICAgICA9IFwiIzAwMDAwMFwiKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJPZiBTaGFwZXNcbiAgICogQGRlc2NyaXB0aW9uIERyYXcgYSBsaW5lIGJldHdlZW4gdGhlc2UgdHdvIHBvaW50cy5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4MFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkwXG4gICAqIEBwYXJhbSAge051bWJlcn0geDFcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0eWxlXG4gICAqL1xuICBkcmF3TGluZVhZKHgwICAgICAgICAsXG4gICAgeTAgICAgICAgICxcbiAgICB4MSAgICAgICAgLFxuICAgIHkxICAgICAgICAsXG4gICAgc3R5bGUgICAgICAgICA9IFwiIzAwMDAwMFwiKSB7XG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICB0aGlzLmN0eC5saW5lVG8oeDEsIHkxKTtcbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogZHJhd0xpbmVWZWNcbiAgICogQHBhcmFtICB7VmVjdG9yfSB2ZWMwOiBWZWN0b3JcbiAgICogQHBhcmFtICB7VmVjdG9yfSB2ZWMxOiBWZWN0b3JcbiAgICovXG4gIGRyYXdMaW5lVmVjKHZlYzAgICAgICAgICwgdmVjMSAgICAgICAgKSB7XG4gICAgdGhpcy5kcmF3TGluZVhZKHZlYzAuZ2V0KFwieFwiKSwgdmVjMC5nZXQoXCJ5XCIpLCB2ZWMxLmdldChcInhcIiksIHZlYzEuZ2V0KFwieVwiKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRyYXdMaW5lUG9pbnRzXG4gICAqIEBwYXJhbSAge09iamVjdH0gZmlyc3RQb2ludFxuICAgKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBwb2ludHNcbiAgICovXG4gIGRyYXdMaW5lUG9pbnRzKHBvaW50cyAgICAgICAgICAgICAgICkge1xuICAgIGlmICghcG9pbnRzWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB2YWxpZCBpbnB1dHNcIik7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGJlIGdpdmVuIGEgYSBudW1iZXIgb2YgcG9pbnRzIGdyZWF0ZXIgdGhhbiAxXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHMuc2hpZnQoKTtcblxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG5cbiAgICBmb3IgKGxldCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9XG5cbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogQG1lbWJlck9mIFNoYXBlc1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0XG4gICAqIEBwYXJhbSAge051bWJlcn0gZ3JpZFNpemVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjb2xvclxuICAgKi9cbiAgZ3JpZCh3aWR0aCAgICAgICAgLCBoZWlnaHQgICAgICAgICwgZ3JpZFNpemUgICAgICAgICA9IDIwLCBjb2xvciAgICAgICAgID0gXCIjY2NjXCIpIHtcbiAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSBncmlkU2l6ZSkge1xuICAgICAgdGhpcy5jdHgubW92ZVRvKHgsIDApO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gZ3JpZFNpemUpIHtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCB5KTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh3aWR0aCwgeSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHBDaXJjbGVcbiAgICogQG1lbWJlck9mIFNoYXBlc1xuICAgKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcFxuICAgKiBAcmV0dXJuIHtQYXJ0aWNsZX1cbiAgICovXG4gIHBDaXJjbGUocGFydGljbGUgICAgICAgICAgKSB7XG4gICAgdGhpcy5jaXJjbGUoXG4gICAgICBwYXJ0aWNsZS5zdGF0ZS54LFxuICAgICAgcGFydGljbGUuc3RhdGUueSxcbiAgICAgIHBhcnRpY2xlLnN0YXRlLnJhZGl1cyxcbiAgICAgIHBhcnRpY2xlLnN0YXRlLmNvbG9yXG4gICAgKTtcbiAgICByZXR1cm4gcGFydGljbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIHBSZWN0XG4gICAqIEBtZW1iZXJPZiBTaGFwZXNcbiAgICogQHBhcmFtICB7UGFydGljbGV9IHBcbiAgICogQHJldHVybiB7UGFydGljbGV9XG4gICAqL1xuICBwUmVjdChwYXJ0aWNsZSAgICAgICAgICApIHtcbiAgICB0aGlzLnJlY3QoXG4gICAgICBwYXJ0aWNsZS5zdGF0ZS54LFxuICAgICAgcGFydGljbGUuc3RhdGUueSxcbiAgICAgIHBhcnRpY2xlLnN0YXRlLndpZHRoLFxuICAgICAgcGFydGljbGUuc3RhdGUuaGVpZ2h0LFxuICAgICAgcGFydGljbGUuc3RhdGUuY29sb3JcbiAgICApO1xuICAgIHJldHVybiBwYXJ0aWNsZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL3NoYXBlcy5qcyIsIi8qKlxuICogWUFUIHN0YW5kcyBmb3IgWWV0IEFub3RoZXIgVHdlZW4uXG4gKiBXaHkgbm90IGhhdmUgb25lIG1vcmUgcGFja2FnZSB0aGF0IGRvZXMgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIDUwIG91dCB0aGVyZT9cbiAqIFdlbGwgdGhhdHMgYSBnb29kIHF1ZXN0aW9uIHRoYXQgd2lsbCBub3QgYmUgYW5zd2VyZWQgaW4gdGhpcyBjb21tZW50IGJsb2NrLlxuICogVG8gYmUgaG9uZXN0IGl0cyBmb3IgcHJhY3RpY2UgYW5kIGxlYXJuaW5nIHB1cnBvc2VzLiBBbmQgaWYgYW55b25lIGluIHRoZWlyXG4gKiByaWdodCBtaW5kIGFjdGF1bGx5IGJlbmVmaXRzIGZyb20gdGhpcyB0aGVuIHNvIGJlIGl0LlxuICovXG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIik7XG5jb25zdCBldmVudCA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIG9iajoge3g6IDAsIHk6IDB9LFxuICBwcm9wczoge3g6IDEwMCwgeTogMTAwfSxcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgZHVyYXRpb246IDEwMDAsXG59O1xuXG5jb25zdCBldmVudEluc3RhbmNlID0gZXZlbnQuaW5pdCgpO1xuLy8gSW5oZXJpdCBtZXRob2RzIGZyb20gZXZlbnRJbnN0YW5jZVxuY29uc3QgWUFUID0gT2JqZWN0LmNyZWF0ZShldmVudEluc3RhbmNlKTtcblxuWUFULmluaXQgPSBmdW5jdGlvbiBpbml0VHdlZW4ob3B0cykge1xuICAvLyBDYW4gYW5kIHVzZXMgRXZlbnQgYW5kIENsb2NrIG1ldGhvZHMuXG5cbiAgaWYgKCFvcHRzLmNsb2NrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYSBjbG9jayBBUEkuXCIpO1xuICB9XG5cbiAgdGhpcy5fY2xvY2sgPSBvcHRzLmNsb2NrLmluaXQoe1xuICAgIGZwczogb3B0cy5mcHMgfHwgNjAsXG4gIH0pO1xuXG4gIHRoaXMucGFyZW50ID0gZXZlbnRJbnN0YW5jZTtcbiAgdGhpcy50d2VlbnMgPSBbXTtcblxuICAvKipcbiAgICogZWFzaW5nRm5zXG4gICAqIEBkZXNjcmlwdGlvbiBBbGwgZWFzaW5nIGZ1bmN0aW9ucyBhcmUgb3JpZ25pYWxseSB3cml0dGVuXG4gICAqIGJ5IHJvYmVydCBwZW5uZXIsIHRoZSB0d2VlbmluZyBnb2QuXG4gICAqIEhlcmUgZWFjaCBtZXRob2QgaXMgcGFzc2VkIGEgbm9ybWFsaXplZCB2YWx1ZS4gV2hpY2ggaXNcbiAgICogdXN1YWxseSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuIFlvdSBjYW4gdGhpbmsgb2YgdGhpcyBudW1iZXIgYXNcbiAgICogYSBwZXJjZW50YWdlIG9mIGEgcmFuZ2UuIFdpdGggdGhhdCBub3JtbGl6ZWQgdmFsdWUgLyBwZXJjZW50YWdlIHdlXG4gICAqIGNhbiBtYXAgdGhhdCBwZXJjZW50YWdlIHRvIGFub3RoZXIgcmFuZ2UuIFRoaXMgaXMgY2FsbGVkIGludGVycG9sYXRpb24uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy99XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmVhc2luZ0ZucyA9IHtcbiAgICAvLyBIZXJlIHRoaXMgZWFzZSBmdW5jdGlvbiBpcyBsaW5lYXIgYXMgdGhlcmUgaXMgb25seSBvbmVcbiAgICAvLyBuIHZhbHVlLiBFYWNoIGVhc2UgZnVuY3Rpb24gY2FuIGJlIG1hcHBlZCB0byBhIHBvbHlub21pYWwuXG4gICAgZWFzZShjLCBiLCBuKSB7IC8vIHBvbHlub21pYWw6IGF4ICsgYiA9IGM7IHdoZXJlIHggaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWVcbiAgICAgIHJldHVybiBjICogbiArIGI7XG4gICAgfSxcbiAgICBlYXNlSW5RdWFkKGMsIGIsIG4pIHsgLy8gcG9seW5vbWlhbDogMXheMiArIDB4ICsgMCA9IGQ7XG4gICAgICByZXR1cm4gYyAqIChuICogbikgKyBiO1xuICAgIH0sXG4gICAgZWFzZU91dFF1YWQoYywgYiwgbikgeyAvLyBwb2x5bm9taWFsOiAtMXheMiArIDJ4ICsgMCA9IGQ7XG4gICAgICByZXR1cm4gYyAqIChuICogKDIgLSBuKSkgKyBiO1xuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhZChjLCBiLCBuKSB7XG4gICAgICBpZiAoKG4qPTIpIDwgMSkge1xuICAgICAgICByZXR1cm4gYy8yICogKG4qbikgKyBiOyAvLyBQb2x5bm9taWFsIGZvciBoYWxmIHRoZSByYW5nZTpcbiAgICAgICAgLy8gMnheMiArIDB4ICsgMCA9IGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gLWMvMiAqICgoLS1uKSoobi0yKSAtIDEpICsgYjsgLy8gUG9seW5vbWlhbCBmb3IgdGhlIHRoZSB1cHBlclxuICAgICAgLy8gaGFsZiBvZiB0aGUgcmFuZ2U6IC0yeF4yICsgNHggLSAxXG4gICAgfSxcbiAgfTtcblxuICB0aGlzLl9jbG9jay5vbihcInRpY2tcIiwgdGhpcy51cGRhdGVUd2VlbnMsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiB1cGRhdGVUd2VlbnMgLSBVcGRhdGVzIGFsbCB0aGUgdHdlZW4gaW5zdGFuY2VzLlxuICovXG5ZQVQudXBkYXRlVHdlZW5zID0gZnVuY3Rpb24gdXBkYXRlVGVlbnMoKSB7XG4gIHRoaXMudHdlZW5zLmZvckVhY2goKHR3ZWVuKSA9PiB7XG4gICAgaWYgKHR3ZWVuLnRpY2tlci5uZWVkc1VwZGF0ZSkge1xuICAgICAgdHdlZW4udXBkYXRlKHR3ZWVuLnRpY2tlcik7XG4gICAgfVxuXG4gICAgaWYgKCF0d2Vlbi50aWNrZXIubmVlZHNVcGRhdGUgJiZcbiAgICAgICAgdHdlZW4udGlja2VyLlNUQVRFID09PSBcIkRPTkVcIikge1xuICAgICAgdHdlZW4udXBkYXRlKHR3ZWVuLnRpY2tlcik7XG4gICAgICB0d2Vlbi5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAodHdlZW4udGlja2VyLnN0b3BwZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiWW91ciB0d2VlbiBpcyBzdG9wcGVkLlwiKTtcbiAgICB9XG4gIH0pO1xufTtcblxuWUFULmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdHM9e30pIHtcbiAgY29uc3QgWUFUSW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKFlBVCk7XG4gIGNvbnN0IF9vcHRzID0gT2JqZWN0LmFzc2lnbihjbG9uZShERUZBVUxUUyksIG9wdHMpO1xuICBjb25zdCB7ZHVyYXRpb24sIG9iaiwgcHJvcHMsIGVhc2luZywgaWR9ID0gX29wdHM7XG5cbiAgaWYgKCFZQVRJbnN0YW5jZS5lYXNpbmdGbnNbZWFzaW5nXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGVhc2luZyBmdW5jdGlvbiAke2Vhc2luZ30gZG9lcyBub3QgZXhpc3RzYCk7XG4gIH1cblxuICBpZiAoaWQpIHtcbiAgICBpZiAodGhpcy50d2VlbnMuc29tZSgoeCkgPT4geC5pZCA9PT0gaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0d2VlbiB3aXRoIGlkOiAke2lkfSBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9XG5cbiAgICBZQVRJbnN0YW5jZS5pZCA9IGlkO1xuICB9IGVsc2Uge1xuICAgIFlBVEluc3RhbmNlLmlkID0gdGhpcy50d2VlbnMubGVuZ3RoICsgMTtcbiAgfVxuXG4gIFlBVEluc3RhbmNlLnN0YXRlID0gY2xvbmUob2JqKTtcbiAgWUFUSW5zdGFuY2Uub2JqID0gb2JqO1xuICBZQVRJbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICBZQVRJbnN0YW5jZS5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICBZQVRJbnN0YW5jZS5lYXNpbmcgPSBZQVRJbnN0YW5jZS5lYXNpbmdGbnNbZWFzaW5nXTtcbiAgWUFUSW5zdGFuY2UudGlja2VyID0gdGhpcy5fY2xvY2suY3JlYXRlU2xhdmUoe1xuICAgIGlkOiBZQVRJbnN0YW5jZS5pZCxcbiAgICBkdXJhdGlvbjogWUFUSW5zdGFuY2UuZHVyYXRpb24sXG4gIH0pO1xuXG4gIHRoaXMudHdlZW5zLnB1c2goWUFUSW5zdGFuY2UpO1xuICByZXR1cm4gWUFUSW5zdGFuY2U7XG59O1xuXG5ZQVQuZ2V0ID0gZnVuY3Rpb24oaWQpIHtcbiAgaWYgKHRoaXMudHdlZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBZQVRbMF07XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHdlZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy50d2VlbltpXS5pZCA9PT0gaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnR3ZWVuW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbllBVC5yZXdpbmQgPSBmdW5jdGlvbihpZD10aGlzLmlkKSB7XG4gIGNvbnN0IHR3ZWVuID0gdGhpcy5nZXQoaWQpO1xuXG4gIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgdHdlZW4uc3RvcCgpO1xuICB9XG5cbiAgLy8gRmlndXJlIG91dCBhIHdheSB0byBjYWNoZSB0aGUgb2xkIHByb3BzIC8vXG4gIHRoaXMub3B0cy5vYmogPSB0aGlzLm9wdHMucHJvcHM7XG4gIHRoaXMub3B0cy5wcm9wcyA9IHRoaXMub3B0cy5wcm9wc0JlZm9yZVR3ZWVuO1xuXG4gIHR3ZWVuLnN0YXJ0KCk7XG59O1xuXG5ZQVQuc3RhcnRBbGwgPSBmdW5jdGlvbiBzdGFydEFsbCgpIHtcbiAgaWYgKCF0aGlzLnR3ZWVucy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBhcmUgbm8gdHdlZW5zIHRvIHN0YXJ0XCIpO1xuICB9XG5cbiAgdGhpcy50d2VlbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgIHQudGlja2VyLnN0YXJ0KCk7XG4gIH0pO1xuXG4gIHRoaXMuX2Nsb2NrLnN0YXJ0KCk7XG59O1xuXG4vKipcbiAqIHN0b3BBbGwgLSBTdG9wcyBhbGwgdHdlZW5zXG4gKi9cbllBVC5zdG9wQWxsID0gZnVuY3Rpb24gc3RvcEFsbCgpIHtcbiAgaWYgKHRoaXMudHdlZW5zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGFyZSBubyB0d2VlbnMgdG8gc3RvcFwiKTtcbiAgfVxuXG4gIHRoaXMuX2Nsb2NrLnN0b3AoKTtcbn07XG5cbi8qKlxuICogZGVsYXkgLSBob3cgbG9uZyB0byBkZWxheSB0aGUgYW5pbWF0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcmV0dXJuIHtZQVR9XG4gKi9cbllBVC5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KGR1cmF0aW9uKSB7XG4gIHRoaXMudGlja2VyLnN0b3AoKTtcbiAgdGhpcy5vYmogPSBjbG9uZSh0aGlzLnN0YXRlKTtcbiAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRpY2tlci5zdGFydCgpLCBkdXJhdGlvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBzdG9wIC0gc3RvcHMgdGhlIHRpY2tlclxuICogQHJldHVybiB7WUFUfVxuICovXG5ZQVQuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gIHRoaXMudGlja2VyLnN0b3AoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGZpbmlzaCAtIGZpbmlzaGVzIHRoZSB0d2VlbiBhbmltYXRpb25cbiAqIEByZXR1cm4ge1lBVH1cbiAqL1xuWUFULmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgdGhpcy5zdG9wKCk7XG4gIHRoaXMuX2Nsb2NrLnJlbW92ZVNsYXZlKHRoaXMudGlja2VyLmlkKTtcbiAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvcHM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuWUFULnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpZD10aGlzLmlkKSB7XG4gIHRoaXMudHdlZW5zID0gdGhpcy50d2VlbnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgaWYgKHQuaWQgPT09IGlkKSB7XG4gICAgICB0aGlzLl9jbG9jay5yZW1vdmVTbGF2ZSh0LnRpY2tlci5pZCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufTtcblxuWUFULnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh0aWNrZXIpIHtcbiAgaWYgKCF0aWNrZXIubmVlZHNVcGRhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICBjb25zdCB7dGltZVNpbmNlU3RhcnQ6IGRlbHRhLCBkdXJhdGlvbn0gPSB0aWNrZXI7XG4gIGNvbnN0IG5vcm0gPSB1dGlscy5ub3JtYWxpemUoZGVsdGEsIDAsIGR1cmF0aW9uLm1zKTtcblxuICBmb3IgKGxldCBrZXkgaW4gdGhpcy5vYmopIHtcbiAgICBpZiAodGhpcy5vYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKHRoaXMub2JqW2tleV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnByb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnN0YXRlW2tleV0gPSB0aGlzLmVhc2luZyh0aGlzLnByb3BzW2tleV0gLSB0aGlzLm9ialtrZXldLCB0aGlzLm9ialtrZXldLCBub3JtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdGF0ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWUFUO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKlxuICpcbiAqIFRFUk1TIE9GIFVTRSAtIEVBU0lORyBFUVVBVElPTlNcbiAqIFxuICogT3BlbiBzb3VyY2UgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLiBcbiAqIFxuICogQ29weXJpZ2h0IMKpIDIwMDEgUm9iZXJ0IFBlbm5lclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiBcbiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIFxuICogY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3QgXG4gKiBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBcbiAqIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZVxuICogb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvblxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSFxuICogIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTFxuICogIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVUXG4gKiAgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEXG4gKiBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOXG4gKiAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRURcbiAqIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvdHdlZW4uanMiLCIvKipcbiAqIEV2ZW50XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGltcGxlbWVudHMge3V0aWxzfVxuICovXG5jb25zdCBFdmVudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7ICBcblxuLyoqXG4gKiBpbml0XG4gKiBAbWVtYmVyT2YgRXZlbnRcbiAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybiB7RXZlbnR9XG4gKi9cbkV2ZW50LmluaXQgPSBmdW5jdGlvbiBpbml0RXZlbnQoKSB7XG4gIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBlbWl0XG4gKiBAZGVzY3JpcHRpb24gRXhlY3V0ZXMgdGhlIGhhbmRlbGVyIHRoYXQgYXNzb2NhaXRlZCB3aXRoIHRoZSBlbWl0dGVkIGV2ZW50LlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RXZlbnR9XG4gKi9cbkV2ZW50LmVtaXQgPSBmdW5jdGlvbiBlbWl0KC4uLmFyZ3MpIHtcbiAgY29uc3QgW2V2ZW50LCAuLi5yZXN0XSA9IGFyZ3M7XG5cbiAgaWYgKCFldmVudCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFdmVudDogUGxlYXNlIHByb3ZpZGUgdHJ1dGh5IGFyZ3VtZW50c1wiKTtcbiAgfVxuXG4gIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcblxuICBpZiAodGhpcy5jYWxsYmFja3NbZXZlbnRdLmxlbmd0aCkge1xuICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2soLi4ucmVzdCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogb25cbiAqIEBkZXNjcmlwdGlvbiBBdHRhY2ggYSBoYW5kbGVyIHRvIGFuIGV2ZW50LlxuICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSAge09iamVjdH0gICBjb250ZXh0XG4gKiBAcmV0dXJuIHtFdmVudH1cbiAqL1xuRXZlbnQub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgaWYgKCFldmVudCB8fCAhZm4pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXZlbnQ6IFBsZWFzZSBwcm92aWRlIHRydXRoeSBhcmd1bWVudHNcIik7XG4gIH1cblxuICBpZiAoY29udGV4dCkge1xuICAgIGZuID0gZm4uYmluZChjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnN0IGV2ZW50cyA9IGV2ZW50LnNwbGl0KFwiIFwiKTtcblxuICB0aGlzLmNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGV2ZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgdGhpcy5jYWxsYmFja3NbZV0gPSB0aGlzLmNhbGxiYWNrc1tlXSB8fCBbXTtcblxuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tlXS5wdXNoKGZuKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIERvbnQgY3JlYXRlIGR1cGxpY2F0ZXMgb2YgdGhlIHNhbWUgaGFuZGVsZWQgZnVuY3Rpb24uXG4gICAgLy8gSWYgeW91IHdhbnQgeW91ciBmdW5jdGlvbiBydW4gdHdpY2Ugd3JhcCBpdCBpbiBhIGZ1bmN0aW9uLlxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrc1tlXS5ldmVyeSgoY2IsIGksIGNvbCkgPT4ge1xuICAgICAgcmV0dXJuIGNiICE9PSBmbjtcbiAgICB9KSA/IHRoaXMuY2FsbGJhY2tzW2VdLnB1c2goZm4pIDpcbiAgICAgIGNvbnNvbGUud2FybihgRXZlbnQ6IFRoYXQgZnVuY3Rpb24gJHtmbn0gaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCBhYCArXG4gICAgICAgIFwiaGFuZGxlciBmb3IgdGhpcyBldmVudC5cIik7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBvZmZcbiAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgYW4gZXZlbnQgaGFuZGVsZXIuXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RXZlbnR9XG4gKi9cbkV2ZW50Lm9mZiA9IGZ1bmN0aW9uIG9mZiguLi5hcmdzKSB7XG4gIGNvbnN0IFtldmVudCwgZm5dID0gYXJncztcblxuICBpZiAoIWV2ZW50KSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICBjb25zb2xlLndhcm4oYEV2ZW50OiBObyBldmVudCBuYW1lZCAke2V2ZW50fSBoYXMgYmVlbiByZWdpc3RlcmVkYCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIWZuKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoKGNiKSA9PiBjYiAhPT0gZm4pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBsaXN0ZW5lcnMgLSBSZXR1cm4gYWxsIGNhbGxiYWNrcyBhdHRhY2hlZCB0byBhIGNlcnRhaW4gZXZlbnRcbiAqIEBwYXJhbSAge2FueTxBcnJheT59IGFyZ3NcbiAqIEByZXR1cm4ge2Z1bmN0aW9uW119XG4gKi9cbkV2ZW50Lmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyguLi5hcmdzKSB7XG4gIGNvbnN0IFtldmVudF0gPSBhcmdzO1xuXG4gIGlmICghZXZlbnQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jYWxsYmFja3MpO1xuICB9XG5cbiAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudF0pIHtcbiAgICBjb25zb2xlLndhcm4oYEV2ZW50OiBObyBldmVudCBuYW1lZCAke2V2ZW50fSBoYXMgYmVlbiByZWdpc3RlcmVkYCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xufTtcblxuRXZlbnQub25jZSA9IGZ1bmN0aW9uIG9uY2UoLi4uYXJncykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgW2V2ZW50LCBmbiwgY29udGV4dF0gPSBhcmdzO1xuXG4gIGNvbnN0IHdyYXAgPSBmdW5jdGlvbiB3cmFwKCkge1xuICAgIGZuLmJpbmQoY29udGV4dCkoKTtcbiAgICBzZWxmLm9mZihldmVudCwgd3JhcCk7XG4gIH07XG5cbiAgdGhpcy5vbihldmVudCwgd3JhcCwgY29udGV4dCk7XG59O1xuXG4vLyBBbGlhc2VzIC8vXG5FdmVudC5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50LnJlbW92ZUFsbExpc3RlbmVycyA9IEV2ZW50Lm9mZjtcbkV2ZW50LmZpcmUgPSBFdmVudC5lbWl0O1xuRXZlbnQuYWRkTGlzdGVuZXIgPSBFdmVudC5vbjtcbkV2ZW50LmdldCA9IEV2ZW50Lmxpc3RlbmVycztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvZXZlbnQuanMiLCJjb25zdCB0aWNrZXIgPSByZXF1aXJlKFwiLi90aWNrZXJcIik7XG5jb25zdCBldmVudCA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpLmluaXQoKTtcbmNvbnN0IENsb2NrID0gT2JqZWN0LmNyZWF0ZShldmVudCk7XG5jb25zdCBNQVhfRlBTID0gNjA7XG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qKlxuICogaW5pdCAtIEluaXRhbGl6ZXMgdGhlIGNsb2NrIHdpdGggY29ycmVjdCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG9wdHMuZnBzIFRoZSBmcHMgeW91IHdhbnQgdGhlIGNsb2NrIHRvIHRpY2sgYXQuXG4gKiBAcmV0dXJuIHtDbG9ja31cbiAqL1xuQ2xvY2suaW5pdCA9IGZ1bmN0aW9uIGluaXRDbG9jayhvcHRzPXt9KSB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBmcHM6IE1BWF9GUFMsXG4gIH0sIG9wdHMpO1xuXG4gIHRoaXMuc2xhdmVzID0gW107XG4gIHRoaXMucGFyZW50ID0gZXZlbnQ7XG5cbiAgLy8gWmVybyBiYXNlZCBmcmFtZSBjb3VudC5cbiAgdGhpcy5pbmRleCA9IC0xO1xuXG4gIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGFuaW1hdGlvbiBmcmFtZSBzbyB3ZSBjYW4gY2FuY2VsIGl0XG4gIHRoaXMuckFGID0gMDtcblxuICAvLyBUaW1lIHByb3BlcnRpZXNcbiAgdGhpcy5zdGFydFRpbWU7XG4gIHRoaXMubGFzdFRpbWU7XG4gIHRoaXMuc3RvcFRpbWU7XG4gIHRoaXMudGltZVNpbmNlU3RhcnQgPSAwO1xuXG4gIC8vIFRoZSBtYXhpbXVtIEZQUyB0aGUgYnJvd3NlciBjYW4gZGVsaXZlciBpcyA2MC5cbiAgdGhpcy5mcHMgPSBvcHRzLmZwcyA+IE1BWF9GUFMgP1xuICAgIE1BWF9GUFMgOlxuICAgIChvcHRzLmZwcyB8fCBNQVhfRlBTKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogc3RhcnQgLSBTdGFydHMgdGhlIGNsb2NrIHdpdGggc3RhcnRpbmcgdGltZSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtICB7TnVtYmVyfSBmcHMgVGhlIGZwcyB5b3Ugd2FudCB0aGUgY2xvY2sgdG8gdGljayBhdC5cbiAqIEByZXR1cm4ge0Nsb2NrfVxuICovXG5DbG9jay5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICBpZiAodGhpcy5mcHMgPiA2MCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBnaXZlbiBmcHMgaXMgdG9vIGhpZ2hcIik7XG4gIH1cblxuICBpZiAoK3RoaXMuZnBzID09PSBOYU4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ2l2ZW4gZnBzIGlzIG5vdCB2YWxpZFwiKTtcbiAgfVxuXG4gIHRoaXMuZnBzID0gMTAwMCAvIHRoaXMuZnBzO1xuICB0aGlzLnN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICB0aGlzLmxhc3RUaW1lID0gdGhpcy5zdGFydFRpbWU7XG5cbiAgLy8gU3RhcnQgdGlja2luZ1xuICB0aGlzLmxvb3AodGhpcy5zdGFydFRpbWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogdGlja1xuICogQHBhcmFtICB7TnVtYmVyfSBuZXdUaW1lIEEgdmFsdWUgaW4gbXMgdGhhdCBpcyBlcXVhbCB0byB0aGUgY3VycmVudCB0aW1lLlxuICogQHJldHVybiB7Q2xvY2t9XG4gKi9cbkNsb2NrLmxvb3AgPSBmdW5jdGlvbiBsb29wKG5ld1RpbWUpIHtcbiAgdGhpcy5yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcC5iaW5kKHRoaXMpKTtcblxuICBsZXQgZGVsdGEgPSBuZXdUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgdGhpcy50aW1lU2luY2VTdGFydCA9IG5ld1RpbWUgLSB0aGlzLnN0YXJ0VGltZTtcblxuICBpZiAoZGVsdGEgPiB0aGlzLmZwcykge1xuICAgIHRoaXMuaW5kZXgrKztcblxuICAgIHRoaXMud2hpcFNsYXZlcyh7XG4gICAgICBuZXdUaW1lLFxuICAgICAgZGVsdGEsXG4gICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgIGxhc3RUaW1lOiB0aGlzLmxhc3RUaW1lLFxuICAgICAgY2xvY2tTdGFydDogdGhpcy5zdGFydFRpbWUsXG4gICAgICB0aW1lU2luY2VTdGFydDogdGhpcy50aW1lU2luY2VTdGFydCxcbiAgICB9KTtcblxuICAgIHRoaXMubGFzdFRpbWUgPSBuZXdUaW1lIC0gKGRlbHRhICUgdGhpcy5mcHMpO1xuICB9XG5cbiAgdGhpcy5lbWl0KFwicmVuZGVyXCIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBzdG9wIC0gU3RvcCB0aGUgY2xvY2sgYW5kIGNhbGwgdGhlIGxhc3QgdGljayBpZiBuZWVkZWQuXG4gKiBAcmV0dXJuIHtDbG9ja31cbiAqL1xuQ2xvY2suc3RvcCA9IGZ1bmN0aW9uIHN0b3BDbG9jaygpIHtcbiAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yQUYpO1xuXG4gIC8vIFJlY29yZCB3aGVuIHdlIHN0b3BwZWQuXG4gIHRoaXMuc3RvcFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgdGhpcy50aW1lU2luY2VTdGFydCArPSB0aGlzLnN0b3BUaW1lIC0gdGhpcy5zdGFydFRpbWU7XG4gIHRoaXMuY2xlYXJTbGF2ZXMoKTtcblxuICB0aGlzLmVtaXQoXCJzdG9wcGVkXCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogd2hpcFNsYXZlcyAtIFJ1biBhbGwgc2xhdmVzIGluIHNlcXVlbmNlIGFuZCBwYXNzIGluXG4gKiB0aGUgZ2l2ZW4gc3RhdGUgb2YgdGhlIGNsb2NrLlxuICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZVxuICogQHJldHVybiB7Q2xvY2t9XG4gKi9cbkNsb2NrLndoaXBTbGF2ZXMgPSBmdW5jdGlvbiB3aGlwU2xhdmVzKHN0YXRlKSB7XG4gIGlmICghdGhpcy5zbGF2ZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5zbGF2ZXMuZm9yRWFjaCgoc2xhdmUsIGluZGV4KSA9PiB7XG4gICAgc2xhdmUubnVkZ2Uoc3RhdGUpO1xuICB9KTtcblxuICB0aGlzLmVtaXQoXCJ0aWNrXCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkNsb2NrLmNyZWF0ZVNsYXZlID0gZnVuY3Rpb24gY3JlYXRlU2xhdmUob3B0cykge1xuICBpZiAoIW9wdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIG9wdGlvbnMgb2JqZWN0XCIpO1xuICB9XG5cbiAgY29uc3Qge2lkLCBkdXJhdGlvbn0gPSBvcHRzO1xuICBjb25zdCB0aW1lU3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBjb25zdCBzbGF2ZSA9IE9iamVjdC5jcmVhdGUodGlja2VyKVxuICAgIC5pbml0KHt0aW1lU3RhbXAsIGlkLCBkdXJhdGlvbn0pO1xuXG4gIGlmIChpZCkge1xuICAgIHRoaXMuc2xhdmVzLnB1c2goc2xhdmUpO1xuICAgIHJldHVybiBzbGF2ZTtcbiAgfVxuXG4gIHNsYXZlLmlkID0gdGhpcy5zbGF2ZXMucHVzaChzbGF2ZSk7XG4gIHJldHVybiBzbGF2ZTtcbn07XG5cbkNsb2NrLnJlbW92ZVNsYXZlID0gZnVuY3Rpb24gcmVtb3ZlU2xhdmUoaWQpIHtcbiAgdGhpcy5zbGF2ZXMgPSB0aGlzLnNsYXZlcy5maWx0ZXIoKHNsYXZlKSA9PiB7XG4gICAgaWYgKHNsYXZlLmlkICE9PSBpZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNsYXZlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59O1xuXG5DbG9jay5jbGVhclNsYXZlcyA9IGZ1bmN0aW9uIGNsZWFyU2xhdmVzKCkge1xuICBpZiAodGhpcy5zbGF2ZXMubGVuZ3RoKSB0aGlzLnNsYXZlcyA9IFtdO1xufTtcblxuQ2xvY2sucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdG9wKCk7XG4gIHRoaXMuY2xlYXJTbGF2ZXMoKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5yQUYgPSAwO1xufTtcblxuQ2xvY2sucmVtb3ZlQWxsU2xhdmVzID0gQ2xvY2suY2xlYXJTbGF2ZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL2Nsb2NrLmpzIiwiY29uc3QgZXZlbnQgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcbmNvbnN0IE1BWF9GUFMgPSAxMDAwLzYwO1xuY29uc3QgVGlja2VyID0gT2JqZWN0LmNyZWF0ZShldmVudCk7XG5jb25zdCBTVEFURSA9IHtcbiAgU1RPUFBFRDogXCJTVE9QUEVEXCIsXG4gIFJVTk5JTkc6IFwiUlVOTklOR1wiLFxuICBET05FOiBcIkRPTkVcIixcbn07XG5cblxuVGlja2VyLmluaXQgPSBmdW5jdGlvbiBpbml0KHtcbiAgdGltZVN0YW1wPXBlcmZvcm1hbmNlLm5vdygpLFxuICBpZCxcbiAgZHVyYXRpb249MTAwMCxcbiAgaW50ZXJ2YWw9TUFYX0ZQUyxcbn0pIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLnBhcmVudCA9IGV2ZW50O1xuICB0aGlzLnBhcmVudC5uYW1lID0gXCJldmVudFwiO1xuXG4gIC8vIFByb2JhYmx5IGNhbnQgc3VwcG9ydCB0aGlzPz9cbiAgLy8gWW91IGhhdmUgdG8gaGF2ZSB5b3VyIG93biBjbG9jay5cbiAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICB0aGlzLmR1cmF0aW9uID0gdGhpcy50aWNrRm9yKGR1cmF0aW9uLCBcIm1zXCIpO1xuXG4gIHRoaXMuU1RBVEU7XG4gIHRoaXMuZGVsdGE7XG4gIHRoaXMuc3RvcFRpbWU7XG4gIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgdGhpcy50aW1lU2luY2VTdGFydCA9IDA7XG4gIHRoaXMudGltZVNpbmNlU3RhcnQyID0gMDtcblxuICAvLyBGaXJlIHRoZSBmaXJzdCB0aW1lIHlvdSBnZXQgY2FsbGVkLlxuICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblRpY2tlci50aWNrRm9yID0gZnVuY3Rpb24gdGlja0ZvcihkdXJhdGlvbiwgc3RyaW5nKSB7XG4gIHN3aXRjaCAoc3RyaW5nKSB7XG4gIGNhc2UgXCJmcmFtZXNcIjogY2FzZSBcImZcIjpcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmcmFtZXNcIixcbiAgICAgIHZhbHVlOiBkdXJhdGlvbixcbiAgICAgIG1zOiBkdXJhdGlvbiAqIE1BWF9GUFMsXG4gICAgfTtcbiAgY2FzZSBcInNlY29uZHNcIjogY2FzZSBcInNcIjpcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzZWNvbmRzXCIsXG4gICAgICB2YWx1ZTogZHVyYXRpb24sXG4gICAgICBtczogZHVyYXRpb24gKiAxMDAwLFxuICAgIH07XG4gIGNhc2UgXCJtaWxsaXNlY29uZHNcIjogY2FzZSBcIm1zXCI6IGRlZmF1bHQ6XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICB2YWx1ZTogZHVyYXRpb24sXG4gICAgICBtczogZHVyYXRpb24sXG4gICAgfTtcbiAgfTtcbn07XG5cblRpY2tlci5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICBpZiAodGhpcy5TVEFURSA9PT0gU1RBVEUuUlVOTklORykgcmV0dXJuIGZhbHNlO1xuICB0aGlzLlNUQVRFID0gU1RBVEUuUlVOTklORztcbiAgdGhpcy5zdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbn07XG5cblRpY2tlci5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgaWYgKHRoaXMuU1RBVEUgPT09IFNUQVRFLlNUT1BQRUQpIHJldHVybiBmYWxzZTtcbiAgdGhpcy5TVEFURSA9IFNUQVRFLlNUT1BQRUQ7XG5cbiAgLy8gS25vdyB3aGF0IHRpbWUgaXQgc3RvcHBlZC5cbiAgLy8gc28gdGhhdCBpZiBpdCBzdGFydHMgYWdhaW4gaXRcbiAgLy8gaXQgY2FuIHJlY2FsY3VsYXRlIGhvdyBmYXIgaXQgbmVlZHMgdG8gZ28uXG4gIGNvbnN0IG5ld0R1cmF0aW9uID0gdGhpcy5kdXJhdGlvbi5tcyAtIHRoaXMudGltZVNpbmNlU3RhcnQgfHwgMDtcblxuICB0aGlzLmR1cmF0aW9uID0gdGhpcy50aWNrRm9yKG5ld0R1cmF0aW9uLCBcIm1pbGxpc2Vjb25kc1wiKTtcbiAgdGhpcy50aW1lU2luY2VTdGFydCA9IDA7XG5cbiAgdGhpcy5zdG9wVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xufTtcblxuVGlja2VyLm51ZGdlID0gZnVuY3Rpb24gbnVkZ2Uoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgc3RhdGUgb2JqZWN0XCIpO1xuICB9XG5cblxuICBpZiAodGhpcy5TVEFURSA9PT0gU1RBVEUuU1RPUFBFRCB8fCB0aGlzLlNUQVRFICE9PSBTVEFURS5SVU5OSU5HKSB7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdGhpcy5TVEFURSA9IFNUQVRFLlJVTk5JTkc7XG4gIHRoaXMudGltZVNpbmNlU3RhcnQgKz0gc3RhdGUuZGVsdGE7XG5cbiAgaWYgKHRoaXMudGltZVNpbmNlU3RhcnQgPCB0aGlzLmR1cmF0aW9uLm1zKSB7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5TVEFURSA9IFNUQVRFLkRPTkU7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpY2tlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvdGlja2VyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../particle_library/dist/main.js\n// module id = 3\n// module chunks = 0","const FIRST_IFRAME = true;\n\nmodule.exports = function iframeHandler(document) {\n  document = document || this.document;\n\n  const domHelper = require(\"dom_helper\")(document);\n  const shims = require(\"shims\")(document);\n\n  const $ = shims.$;\n  const $$ = shims.$$;\n\n  let firstState = FIRST_IFRAME;\n\n  const checkStatus = (res) => {\n    const status = res.status;\n\n    if (status >= 200 && status < 400) {\n      return res;\n    }\n\n    console.log(`Bad status: ${status}`);\n    throw res.statusText;\n  };\n\n  /**\n   * [fetchExample description]\n   * @param  {[type]} id [description]\n   * @return {[type]}    [description]\n   */\n  const fetchExample = function fetchExample(id) {\n    return fetch(\"/examples/\" + id)\n    .then(checkStatus)\n    .then((res) => res.text());\n  };\n\n\n  /**\n   * [writeFrame description]\n   * @param  {[type]} parent [description]\n   * @param  {[type]} frame  [description]\n   * @return {[type]}        [description]\n   */\n  const writeFrame = function writeFrame(parent, frame) {\n    if (!domHelper.isElement(parent) || !domHelper.isElement(frame)) {\n      throw new Error(parent + \" this parent isn't a DOM element.\");\n    }\n    return parent.appendChild(frame);\n  };\n\n  /**\n   * [getFrame description]\n   * @param  {[type]} name [description]\n   * @return {[type]}      [description]\n   */\n  const getFrame = function getFrame(name) {\n    if (!name) return $(\"iframe[data-example]\");\n    return $(\"iframe[data-example^=\" + name + \"]\");\n  };\n\n  /**\n   * [injectSrc description]\n   * @param  {[type]} src   [description]\n   * @param  {[type]} frame [description]\n   * @return {[type]}       [description]\n   */\n  const injectSrc = function injectSrc(src, frame) {\n    frame.srcdoc = src;\n    return frame;\n  };\n\n  /**\n   * [createFrame description]\n   * @param  {[type]} name [description]\n   * @return {[type]}      [description]\n   */\n  const createFrame = function createFrame(name) {\n    if (!name || typeof name !== \"string\") {\n      throw new Error(name + \" Not a valid name for a id.\");\n    }\n\n    const iframe = document.createElement(\"iframe\");\n\n    iframe.setAttribute(\"allow-same-origin\", true);\n    iframe.setAttribute(\"allow-scripts\", true);\n    iframe.setAttribute(\"allowfullscreen\", true);\n    iframe.setAttribute(\"class\", \"frame_example\");\n    iframe.setAttribute(\"data-example\", name);\n\n    return iframe;\n  };\n\n  /**\n   * [removeFrameSrc description]\n   * @param  {[type]} target [description]\n   * @return {[type]}        [description]\n   */\n  const removeFrameSrc = function removeFrameSrc(target) {\n    if (!target) throw new Error(\"Please provide a target\");\n\n    if (!domHelper.isElement(target)) {\n      return getFrame(target).srcDoc = \"\";\n    }\n    return target.srcDoc = \"\";\n  };\n\n  /**\n   * exampleExists - check if example exsists\n   * @param  {String} example\n   * @return {Boolean}\n   */\n  const exampleExists = function exampleExists(example) {\n    if (!example) return false;\n\n    let id;\n\n    try {\n      id = getFrame(example)\n        .attributes[\"data-example\"]\n        .nodeValue;\n\n      return id === example;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  /**\n   * loadInIframe\n   * @param  {String} name\n   * @return {Promise}\n   */\n  const loadInIframe = function loadInIframe(id) { \n    const existingFrame = getFrame();\n\n    if (exampleExists(id)) {\n      return false;\n    }\n  \n    if (firstState) {\n      // Toggle the state.\n      firstState = !firstState;\n      // Create the frame\n      const firstFrame = createFrame(id);\n      const parentDiv = $(\".wrapper__frame\");\n      // If we are not the first frame of the document do this regular stuff.\n      return fetchExample(id)\n        .then((src) => injectSrc(src, firstFrame))\n        .then((newFrame) => writeFrame(parentDiv, newFrame))\n        .catch(errorDialog);\n    }\n\n    if (!existingFrame) {\n      return;\n    }\n    // Toggle the state and remove old src and inject new src.\n    removeFrameSrc(existingFrame);\n    existingFrame.setAttribute(\"data-example\", id);\n    return fetchExample(id)\n      .then((src) => injectSrc(src, existingFrame))\n      .catch(errorDialog);\n  };\n\n  const errorDialog = function(err) {\n    if ($(\".dialog_error\").textContent !== err) {\n      $(\".dialog_error\").style.display = \"block\";\n      $(\".dialog_error\").insertAdjacentText(\"afterBegin\", err);\n    }\n  };\n\n  return {\n    removeFrameSrc,\n    writeFrame,\n    getFrame,\n    injectSrc,\n    createFrame,\n    loadInIframe,\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/module/iframeManager.js\n// module id = 4\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js??ref--0-2!../../node_modules/sass-loader/lib/loader.js??ref--0-3!./main.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {\"hmr\":true}\noptions.transform = transform\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js??ref--0-2!../../node_modules/sass-loader/lib/loader.js??ref--0-3!./main.scss\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js??ref--0-2!../../node_modules/sass-loader/lib/loader.js??ref--0-3!./main.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/styles/main.scss\n// module id = 5\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \"/*! normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css */\\n/**\\n * 1. Change the default font family in all browsers (opinionated).\\n * 2. Correct the line height in all browsers.\\n * 3. Prevent adjustments of font size after orientation changes in\\n *    IE on Windows Phone and in iOS.\\n */\\n/* Document\\n   ========================================================================== */\\nhtml {\\n  font-family: sans-serif;\\n  /* 1 */\\n  line-height: 1.15;\\n  /* 2 */\\n  -ms-text-size-adjust: 100%;\\n  /* 3 */\\n  -webkit-text-size-adjust: 100%;\\n  /* 3 */ }\\n\\n/* Sections\\n   ========================================================================== */\\n/**\\n * Remove the margin in all browsers (opinionated).\\n */\\nbody {\\n  margin: 0; }\\n\\n/**\\n * Add the correct display in IE 9-.\\n */\\narticle,\\naside,\\nfooter,\\nheader,\\nnav,\\nsection {\\n  display: block; }\\n\\n/**\\n * Correct the font size and margin on `h1` elements within `section` and\\n * `article` contexts in Chrome, Firefox, and Safari.\\n */\\nh1 {\\n  font-size: 2em;\\n  margin: 0.67em 0; }\\n\\n/* Grouping content\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 9-.\\n * 1. Add the correct display in IE.\\n */\\nfigcaption,\\nfigure,\\nmain {\\n  /* 1 */\\n  display: block; }\\n\\n/**\\n * Add the correct margin in IE 8.\\n */\\nfigure {\\n  margin: 1em 40px; }\\n\\n/**\\n * 1. Add the correct box sizing in Firefox.\\n * 2. Show the overflow in Edge and IE.\\n */\\nhr {\\n  box-sizing: content-box;\\n  /* 1 */\\n  height: 0;\\n  /* 1 */\\n  overflow: visible;\\n  /* 2 */ }\\n\\n/**\\n * 1. Correct the inheritance and scaling of font size in all browsers.\\n * 2. Correct the odd `em` font sizing in all browsers.\\n */\\npre {\\n  font-family: monospace, monospace;\\n  /* 1 */\\n  font-size: 1em;\\n  /* 2 */ }\\n\\n/* Text-level semantics\\n   ========================================================================== */\\n/**\\n * 1. Remove the gray background on active links in IE 10.\\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\\n */\\na {\\n  background-color: transparent;\\n  /* 1 */\\n  -webkit-text-decoration-skip: objects;\\n  /* 2 */ }\\n\\n/**\\n * Remove the outline on focused links when they are also active or hovered\\n * in all browsers (opinionated).\\n */\\na:active,\\na:hover {\\n  outline-width: 0; }\\n\\n/**\\n * 1. Remove the bottom border in Firefox 39-.\\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\\n */\\nabbr[title] {\\n  border-bottom: none;\\n  /* 1 */\\n  text-decoration: underline;\\n  /* 2 */\\n  text-decoration: underline dotted;\\n  /* 2 */ }\\n\\n/**\\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\\n */\\nb,\\nstrong {\\n  font-weight: inherit; }\\n\\n/**\\n * Add the correct font weight in Chrome, Edge, and Safari.\\n */\\nb,\\nstrong {\\n  font-weight: bolder; }\\n\\n/**\\n * 1. Correct the inheritance and scaling of font size in all browsers.\\n * 2. Correct the odd `em` font sizing in all browsers.\\n */\\ncode,\\nkbd,\\nsamp {\\n  font-family: monospace, monospace;\\n  /* 1 */\\n  font-size: 1em;\\n  /* 2 */ }\\n\\n/**\\n * Add the correct font style in Android 4.3-.\\n */\\ndfn {\\n  font-style: italic; }\\n\\n/**\\n * Add the correct background and color in IE 9-.\\n */\\nmark {\\n  background-color: #ff0;\\n  color: #000; }\\n\\n/**\\n * Add the correct font size in all browsers.\\n */\\nsmall {\\n  font-size: 80%; }\\n\\n/**\\n * Prevent `sub` and `sup` elements from affecting the line height in\\n * all browsers.\\n */\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline; }\\n\\nsub {\\n  bottom: -0.25em; }\\n\\nsup {\\n  top: -0.5em; }\\n\\n/* Embedded content\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 9-.\\n */\\naudio,\\nvideo {\\n  display: inline-block; }\\n\\n/**\\n * Add the correct display in iOS 4-7.\\n */\\naudio:not([controls]) {\\n  display: none;\\n  height: 0; }\\n\\n/**\\n * Remove the border on images inside links in IE 10-.\\n */\\nimg {\\n  border-style: none; }\\n\\n/**\\n * Hide the overflow in IE.\\n */\\nsvg:not(:root) {\\n  overflow: hidden; }\\n\\n/* Forms\\n   ========================================================================== */\\n/**\\n * 1. Change the font styles in all browsers (opinionated).\\n * 2. Remove the margin in Firefox and Safari.\\n */\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: sans-serif;\\n  /* 1 */\\n  font-size: 100%;\\n  /* 1 */\\n  line-height: 1.15;\\n  /* 1 */\\n  margin: 0;\\n  /* 2 */ }\\n\\n/**\\n * Show the overflow in IE.\\n * 1. Show the overflow in Edge.\\n */\\nbutton,\\ninput {\\n  /* 1 */\\n  overflow: visible; }\\n\\n/**\\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\\n * 1. Remove the inheritance of text transform in Firefox.\\n */\\nbutton,\\nselect {\\n  /* 1 */\\n  text-transform: none; }\\n\\n/**\\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\\n *    controls in Android 4.\\n * 2. Correct the inability to style clickable types in iOS and Safari.\\n */\\nbutton,\\nhtml [type=\\\"button\\\"],\\n[type=\\\"reset\\\"],\\n[type=\\\"submit\\\"] {\\n  -webkit-appearance: button;\\n  /* 2 */ }\\n\\n/**\\n * Remove the inner border and padding in Firefox.\\n */\\nbutton::-moz-focus-inner,\\n[type=\\\"button\\\"]::-moz-focus-inner,\\n[type=\\\"reset\\\"]::-moz-focus-inner,\\n[type=\\\"submit\\\"]::-moz-focus-inner {\\n  border-style: none;\\n  padding: 0; }\\n\\n/**\\n * Restore the focus styles unset by the previous rule.\\n */\\nbutton:-moz-focusring,\\n[type=\\\"button\\\"]:-moz-focusring,\\n[type=\\\"reset\\\"]:-moz-focusring,\\n[type=\\\"submit\\\"]:-moz-focusring {\\n  outline: 1px dotted ButtonText; }\\n\\n/**\\n * Change the border, margin, and padding in all browsers (opinionated).\\n */\\nfieldset {\\n  border: 1px solid #c0c0c0;\\n  margin: 0 2px;\\n  padding: 0.35em 0.625em 0.75em; }\\n\\n/**\\n * 1. Correct the text wrapping in Edge and IE.\\n * 2. Correct the color inheritance from `fieldset` elements in IE.\\n * 3. Remove the padding so developers are not caught out when they zero out\\n *    `fieldset` elements in all browsers.\\n */\\nlegend {\\n  box-sizing: border-box;\\n  /* 1 */\\n  color: inherit;\\n  /* 2 */\\n  display: table;\\n  /* 1 */\\n  max-width: 100%;\\n  /* 1 */\\n  padding: 0;\\n  /* 3 */\\n  white-space: normal;\\n  /* 1 */ }\\n\\n/**\\n * 1. Add the correct display in IE 9-.\\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\\n */\\nprogress {\\n  display: inline-block;\\n  /* 1 */\\n  vertical-align: baseline;\\n  /* 2 */ }\\n\\n/**\\n * Remove the default vertical scrollbar in IE.\\n */\\ntextarea {\\n  overflow: auto; }\\n\\n/**\\n * 1. Add the correct box sizing in IE 10-.\\n * 2. Remove the padding in IE 10-.\\n */\\n[type=\\\"checkbox\\\"],\\n[type=\\\"radio\\\"] {\\n  box-sizing: border-box;\\n  /* 1 */\\n  padding: 0;\\n  /* 2 */ }\\n\\n/**\\n * Correct the cursor style of increment and decrement buttons in Chrome.\\n */\\n[type=\\\"number\\\"]::-webkit-inner-spin-button,\\n[type=\\\"number\\\"]::-webkit-outer-spin-button {\\n  height: auto; }\\n\\n/**\\n * 1. Correct the odd appearance in Chrome and Safari.\\n * 2. Correct the outline style in Safari.\\n */\\n[type=\\\"search\\\"] {\\n  -webkit-appearance: textfield;\\n  /* 1 */\\n  outline-offset: -2px;\\n  /* 2 */ }\\n\\n/**\\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\\n */\\n[type=\\\"search\\\"]::-webkit-search-cancel-button,\\n[type=\\\"search\\\"]::-webkit-search-decoration {\\n  -webkit-appearance: none; }\\n\\n/**\\n * 1. Correct the inability to style clickable types in iOS and Safari.\\n * 2. Change font properties to `inherit` in Safari.\\n */\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button;\\n  /* 1 */\\n  font: inherit;\\n  /* 2 */ }\\n\\n/* Interactive\\n   ========================================================================== */\\n/*\\n * Add the correct display in IE 9-.\\n * 1. Add the correct display in Edge, IE, and Firefox.\\n */\\ndetails,\\nmenu {\\n  display: block; }\\n\\n/*\\n * Add the correct display in all browsers.\\n */\\nsummary {\\n  display: list-item; }\\n\\n/* Scripting\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 9-.\\n */\\ncanvas {\\n  display: inline-block; }\\n\\n/**\\n * Add the correct display in IE.\\n */\\ntemplate {\\n  display: none; }\\n\\n/* Hidden\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 10-.\\n */\\n[hidden] {\\n  display: none; }\\n\\n@font-face {\\n  font-family: Code Pro Regular;\\n  src: url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Regular.eot\") + \"\\\");\\n  src: url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Regular.eot?iefix\") + \"\\\") format(\\\"embedded-opentype\\\"), url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Regular.woff\") + \"\\\") format(\\\"woff\\\"), url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Regular.svg\") + \"\\\") format(\\\"svg\\\"), url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Regular.ttf\") + \"\\\") format(\\\"truetype\\\");\\n  font-weight: 600;\\n  font-style: none; }\\n\\n@font-face {\\n  font-family: Code Pro Regular;\\n  src: url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Bold.eot\") + \"\\\");\\n  src: url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Bold.eot?iefix\") + \"\\\") format(\\\"embedded-opentype\\\"), url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Bold.woff\") + \"\\\") format(\\\"woff\\\"), url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Bold.svg\") + \"\\\") format(\\\"svg\\\"), url(\\\"\" + require(\"../../public/files/fonts/Code Pro/Code Pro Bold.ttf\") + \"\\\") format(\\\"truetype\\\");\\n  font-weight: bold;\\n  font-style: none; }\\n\\n.row,\\n.row__vertical,\\n.list-examples {\\n  display: flex;\\n  width: 100%; }\\n\\n.row__vertical {\\n  flex-direction: column; }\\n\\n.column,\\n.list-examples li,\\n.navigation__main,\\n.navigation__main ol,\\n.navigation__main ul,\\n.navigation__main li,\\n.header__logo {\\n  margin: 10px;\\n  flex-grow: 1;\\n  flex-shrink: 1;\\n  flex-basis: 0px; }\\n\\n.column__big,\\n.wrapper__content,\\n.wrapper__frame,\\n.wrapper__frame iframe {\\n  flex-grow: 9;\\n  flex-shrink: 9;\\n  flex-basis: 0px; }\\n\\n.frameExample {\\n  width: 80%;\\n  margin: 0 auto; }\\n\\n.list-examples {\\n  flex-direction: column;\\n  overflow: scroll;\\n  height: 50vh;\\n  border: 3px solid rgba(200, 200, 200, 0.5);\\n  border-radius: 10px; }\\n\\n.navigation__main {\\n  height: 100vh; }\\n  .navigation__main h1 {\\n    text-transform: uppercase; }\\n  .navigation__main ol, .navigation__main ul, .navigation__main li {\\n    list-style: none;\\n    padding: 0px;\\n    margin: 2px; }\\n\\n.padded__light,\\n.content-block__small {\\n  padding: 5px; }\\n\\n.padded,\\n.content-block {\\n  padding: 10px; }\\n\\n.padded__heavy,\\n.content-block__large {\\n  padding: 20px; }\\n\\n.spaced__light,\\n.content-block__small {\\n  margin: 5px; }\\n\\n.spaced,\\n.content-block {\\n  margin: 10px; }\\n\\n.spaced__heavy,\\n.content-block__large {\\n  margin: 20px; }\\n\\n.border {\\n  border: 2px solid rgba(200, 200, 200, 0.5);\\n  border-radius: 4px;\\n  box-shadow: 2px rgba(200, 200, 200, 0.5); }\\n\\n.content-block {\\n  line-height: 1.5rem;\\n  font-size: 1.05rem; }\\n\\n.content-block__large {\\n  font-size: 1.05rem; }\\n\\n.content-block__small {\\n  font-size: 1rem; }\\n\\n.code-block {\\n  background-color: rgba(0, 0, 0, 0.1); }\\n\\n.scrollable__vertical {\\n  overflow-y: scroll;\\n  overflow-wrap: break-word; }\\n\\n.anchor-style-none {\\n  text-decoration: none; }\\n\\n.important {\\n  color: white;\\n  list-style: none;\\n  background: rgba(255, 150, 0, 0.8);\\n  font-size: 1.025rem;\\n  font-weight: 600;\\n  padding: 3px;\\n  border-radius: 4%;\\n  line-height: 1.25; }\\n\\n.attention {\\n  color: white;\\n  list-style: none;\\n  background: #ff000a;\\n  font-size: 1.025rem;\\n  font-weight: 100;\\n  padding: 2px;\\n  padding-left: 10px;\\n  line-height: 2; }\\n\\n.dialog, .dialog_error {\\n  height: 20vh;\\n  width: 35vw;\\n  line-height: 100px;\\n  font-weight: bold;\\n  display: none;\\n  z-index: 1; }\\n\\n.dialog_error {\\n  color: white;\\n  background: #ff000a;\\n  text-align: center; }\\n\\n.wrapper__content, .wrapper__frame, .wrapper__frame iframe {\\n  display: flex;\\n  position: relative;\\n  flex-direction: row; }\\n\\n.wrapper__dialog {\\n  position: absolute;\\n  display: flex;\\n  width: 100%;\\n  height: 100%;\\n  align-items: center;\\n  justify-content: center; }\\n\\n.wrapper__page {\\n  overflow-y: hidden;\\n  display: flex;\\n  max-height: 100vh;\\n  height: 100vh; }\\n\\n.wrapper__frame, .wrapper__frame iframe {\\n  height: 100vh; }\\n  .wrapper__frame iframe {\\n    border: none; }\\n\\n.wrapper__error {\\n  display: none;\\n  height: 0;\\n  width: 0; }\\n  .wrapper__error #error {\\n    display: none;\\n    height: 0;\\n    width: 0; }\\n\\n.header__medium {\\n  font-size: 1.75rem;\\n  font-weight: 600;\\n  color: rgba(0, 0, 0, 0.8);\\n  margin: 0.25rem; }\\n\\n.header__logo {\\n  font-family: Code Pro Regular;\\n  font-weight: 200;\\n  padding-left: 0px;\\n  text-align: left;\\n  margin: 0px;\\n  text-transform: uppercase; }\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"sourceMaps\":true}!./node_modules/sass-loader/lib/loader.js?{\"sourceMaps\":true}!./src/styles/main.scss\n// module id = 6\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 7\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Regular.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Regular.eot\n// module id = 8\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Regular.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Regular.eot?iefix\n// module id = 9\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Regular.woff\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Regular.woff\n// module id = 10\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Regular.svg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Regular.svg\n// module id = 11\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Regular.ttf\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Regular.ttf\n// module id = 12\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Bold.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Bold.eot\n// module id = 13\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Bold.eot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Bold.eot?iefix\n// module id = 14\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Bold.woff\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Bold.woff\n// module id = 15\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Bold.svg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Bold.svg\n// module id = 16\n// module chunks = 0","module.exports = \"./publicfiles/Code Pro Bold.ttf\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./public/files/fonts/Code Pro/Code Pro Bold.ttf\n// module id = 17\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tvar styleTarget = fn.call(this, selector);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[selector] = styleTarget;\n\t\t}\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/addStyles.js\n// module id = 18\n// module chunks = 0","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/lib/urls.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}